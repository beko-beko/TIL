<details>
<summary>文</summary>
	
- 文は`;`で終わる
- return文
  	- 関数が返却する値を出す式
  	- returnの後ろに置く式は0個か1個
  	- returnの後ろに置く式は`return a;`でも`return a + b`でも構わない

<details>	
<summary>選択文</summary>

- プログラムの流れを選択的に分岐させる
- if文とswitch文がある

<details>
<summary>if文</summary>
  
> if ( 式 ) 文
- 式を評価してその値が非0（ゼロでなければ）であれば文を実行する
- elseはなくてもよい<br>
  
- 制御式
	- if文の条件判定のために（）内に置かれた式
	- 後ろに`;`を置かないこと
- else
	- 制御式を評価した値が0だった場合elseの文を実行する
```c
if　(　式　)　文
文1（値  =  非0）;
else
文2（値  =  0）;
```
- else if文
	- if文には、if(式)文、if(式)文 else文の2種類しかないが、入れ子にすることで分岐を増やすことが可能
	- else if文は、厳密にはelseの後の文に新たにif文が追加されている形式になる<br><br>
> if文<br>
> else if文<br>
> else文

の形で、else ifは間に入れる
- 非ゼロの判定
```c
if (num)
　puts(”ゼロでない”);
else
　puts(”ゼロ”);
```
　制御式に定数を入れることもできるが、その場合絶対ゼロにはならない
- 0はTrueかFalseか
```c
　int a = 0;

	if (a = 0){
		puts("aは0です");
	} else {
		puts("aは0ではありません");
	}
```
1.&nbsp;&nbsp;aにゼロを代入する<br>
2.&nbsp;&nbsp;もし、<br>
3.&nbsp;&nbsp;式でaにゼロを代入する<br>
4-1.&nbsp;&nbsp;if文は値を評価して非ゼロだった場合最初の文、「aは0です」と表示する<br>
4-2.&nbsp;&nbsp;値を評価してゼロだった場合else文、「aは0ではありません」と表示する<br>
<br>
ifの式で0を代入しているので値はゼロになる。そのため必ずelse文の「aは0ではありません」と表示される<br>
<br>
```c
int a = 0;

	if (a == 0){
		puts("aは0です");
	} else {
		puts("aは0ではありません");
	}
```
1.&nbsp;&nbsp;aにゼロを代入する<br>
2.&nbsp;&nbsp;もし、<br>
3.&nbsp;&nbsp;式でaと0が等しいか評価している<br>
4-1.&nbsp;&nbsp;if文は値を評価して非ゼロだった場合最初の文、「aは0です」と表示する<br>
4-2.&nbsp;&nbsp;値を評価してゼロだった場合else文、「aは0ではありません」と表示する<br>
<br>
「もしaと0が等しければif文の最初の文を返すプログラムなので、aは0です」と表示される<br>

</details>

<details>
<summary>switch文</summary>

> switch ( 制御式 ) 文<br>

```c
switch ( 制御式 ) {
　case 0 :　・・・;　break;
　case 1 :　・・・;　break;
　case 2 :  ・・・;　break;
}
```
<br>

- 単一の式に基づいて、複数の分岐をする場合、簡潔に表現できる
- if文よりswitch文の方が読み間違えや書き間違いと誤解されることが減る
- 制御式を評価した値に基づいて結果に対応するラベルのプログラムに飛ぶ
- ()に囲まれた制御式は整数でなければいけない
 
- ラベル
	- `case 1 :`という形式で書かれる
	- ラベルの値は定数でなければいけない
   	- %cで読み込んだアルファベットを参照して''で囲えばアルファベットも使える
	- 複数のラベルが同じ値を持つことはできない
	- 同じ処理をしたいcaseを上下に並べ、上のcaseを空白にして、break文もおかないことで、同じ処理をさせることができる
	- 「case」と「1」の間の空白は省略不可

- break文
	- ラベルの後の文が実行された後、`break;`とつけることで、switch文を中断させる
   	- 繰り返し文の中にあっても、switch文中であれば、繰り返し文は終了されない
	- break文がないと、次のcaseが続けて実行される
	- 最後のcaseの末尾にもbreak文を置くことで、ラベルの増減に対応できる

- default
	- 制御式を評価した値がどのcaseにも一致しない際に飛ぶラベル

</details>

<details>
<summary>複合文（ブロック）</summary>

- `{}`を使う文
- {0個以上の文または宣言の並び}
- 文は何個でもよく、宣言も何個でもよい
- 文の一種で、構造上は単一の文とみなされる
- if文、elseは1つの文しか制御できない。
- 複数の文を制御するには複合文を使う

</details>

<details>
<summary>繰り返し文</summary>

<details>
<summary>do文</summary>

- 「制御式の評価で得られた値が値が真のあいだ、文を繰り返し実行せよ」という文
- doではじまり、文を挟んで、while(式);で終わる形式
- do「実行せよ」
- while「～のあいだ」
- 繰り返しの対象となる文のことを　ループ本体　という
- do文におけるループ本体は { から } までの複合文
- 継続条件はwhileの次の制御式が真であること
  
```c
do {
   文
} while ( 式 );
```

</details>

<details>
<summary>while文</summary>

- do文はループ本体の実行後に繰り返すか判定していたが、while文では実行前に行う
- do文は一度はループ本体が実行されるが、while文では、制御式の評価が偽であれば一度も実行されない
	```c
 	while ( 制御式 ) {
  	　　文
 	}
 	```
 
</details>

<details>
<summary>break文とcontinue文</summary>

- break文
	- switch文、do文、while文、for文といった選択文のループ本体の中でbreak文が実行されるとループを抜けて次に進む
   	- そのbreakから見て最初の外側の繰り返し文が終了する。ただしswitch文中のbreakはswitch文を終了し、繰り返し文は終了しない

- continue文
	- 選択文のループ本体の中でcontinue文が実行されると「ループ本体の残りの部分の実行」がスキップされて、ループ本体の終端に移動し、最初の制御式まで戻る
   	- for文ではcontinueしてスキップされても式3部分は実行される
   	- そのcontinueから見て最初の外側の繰り返し文が終了する

- 無限ループ
  	選択文の制御式に必ず真とみなされる値(1など)を入れると無限ループする
</details>

<details>
<summary>for文</summary>
	
```c
for (式1; 式2; 式3) 文
```
- 式1は前処理にあたり、一回だけ評価、実行、変数の作成がなされる
- 式2は繰り返すかを決める制御式。真であれば（）の後のループ本体の文が実行される
- 式3は後始末処理あるいは次の繰り返しの準備。式3が実行されてから式2に戻る
```c
scanf("%d", &no); //noに入力された値を代入
	
for (int i = 0; i <= no; i++) // 式1で変数iに0を初期化。式2でnoがi以上になるまで続けると設定。式3でi+1する
printf("%d", i); // 式2の条件を満たす間行う
putchar('\n'); // ループ終了すると改行
```
- 式1　前処理
	- ここで宣言された変数はそのfor文の中だけで使える
	- 別のfor文で同一名の変数を使うときは書くfor文ごとに宣言が必要
	- 変数の宣言が必要のない場合（for文の前に宣言しているなど）、前処理が不要な場合は省略可能
- 式2　制御式
	- この式を省略すると繰り返しの判定は真とみなされる
	- そのためbreak文などを使わない限り無限ループになる
	- 式3　後始末/次の繰り返しの準備
	- 行うことがなければ省略可能
	- すべての式を省略すると
		``` c
		for ( ; ; )
		文
		```
		となる
	- 式を省略する場合でもセミコロンは省略不可能
	- 中断
		```c
		int num;
		printf("整数は何個：");
		fflush(0);
		scanf("%d", &num);
		printf("終了は-9999\n");
		int i; //iをfor文外でも使うので先に定義
		int sum = 0; // 合計値
		for (i = 0; i < num; i++){ //iは中断されても回数カウントに使えるよう0を代入	
		int tmp;
		printf("No.%d：", i + 1); // iを何番目の入力なのかの表示にも使用するため+1する
		fflush(0);
		scanf("%d", &tmp);
		if (tmp == -9999) break; // 入力した値が-9999のとき中断する
		sum += tmp; // 合計値に足し合わせていく
		}

		printf("合計値：%d\n", sum);
		printf("平均値：%.2f\n", (double)sum / i);
		```
</details>

<details>
<summary>多重ループ</summary>

- 繰り返し文のループ本体の中に繰り返し文が含まれていると多重ループが可能
 
</details>

</details>

</details>

</details>

<details>
<summary>式</summary>
  
- 変数や定数、それらを演算子で結合したものを式と呼ぶ<br>
```x + 32;```<br>
では`x`、`32`、`x + 32`のいずれも式とみなす<br>
代入演算子を用いた式は代入式という
- 式を評価する=答えが出る<br>
定数は評価されるとそのままの数が出てくる<br>
Trueは1、Falseは0と出る
  
</details>

<details>
<summary>書式</summary>
	
- printf関数に与える最初の実引数は書式文字列という
- %dは書式の指示で変換指定という
- \n = ¥n = 改行文字
- %zu
  	- size_t型の値をprinttfで出力する書式文字列

<details>
<summary>変換指定</summary>
  
　％０９．９ｆ<br>
　　&nbsp;↓&nbsp;&nbsp;↓&nbsp;&nbsp;&nbsp;↓&nbsp;&nbsp;&nbsp;&nbsp;↓<br>
　　Ａ&nbsp;Ｂ&nbsp;C&nbsp;&nbsp;&nbsp;D<br>
  - A　フラグ
    - 0が指定されていると、数値の前に余白があるとき、０をつめて表示する
    - 文字列の場合はナル文字の字数は含めない、見かけ上の余白に0をつめる
    - このフラグを省略すると空白がつめられる
    - -が指定されると左詰めになり、指定がないと右詰めになる
    - +フラグは右詰めにするフラグで、省略可
    - 2つのフラグを両方使うことはできない。2つ置かれた場合、左側が優先される
  - B　最小フィールド幅
    - 最低限の表示文字数の指定<br>
    この指定が省略されたり、指定された値を超える数値を表示するときは、その数値を表示するのに必要な桁数で表示される
　　 - 精度が最小フィールド幅未満の場合、空いたフィールド幅に空白が詰められる
  - C　精度
    - 表示する最小の桁数の指定<br>
    省略すると、整数の制度は１とされ、浮動小数点数の精度は6とされる
  - D　変換指定子
    - d・・・int型の整数を10進数で表示する指定
    - f・・・double型の浮動小数点数を10進数で表示する指定
    - s・・・文字列を表示する指定。精度を指定しない場合や、精度が配列の大きさより大きい場合は、配列は必ずナル文字を含んでいないといけない
    
</details>

<details>
<summary>変換指定子</summary>
- %o
	- 符号無し整数型を8進数で表示
- %u
	- 符号無し整数型を10進数で表示
- %x
	- 符号無し整数型16進数小文字で表示
- %X
	- 符号無し整数型を16進数大文字で表示
- long,long longを表示する場合は変換指定子の直前にlかllの長さ修飾子を置く
- %d
	- 符号付き整数型を10進数で表示
- %s
	- 文字列を表示する
- %c
	- 一文字のみ表示する
- %zu
	- size_t型の値をprintfする書式文字列
- %p
	- アドレス演算子&で取得したアドレスを表示する
</details>
</details>

<details>
<summary>変数</summary>

- 変数が有効になる範囲は決まっているので宣言する場所に気を付ける
  
- 変数の宣言<br>
> 型&nbsp;&nbsp;&nbsp;名前<br>
> int&nbsp;&nbsp;&nbsp;　n

intという型でnという名前の変数を宣言した<br>
- 変数は定義された型の性質に則って作られる
- 表現できる範囲も型に依存する
  
- 初期化
	- 実数に入れる値がわかっている際、最初から設定すること<br>
		```c
		int x = 57;
		```
		57のように宣言の際に設定する変数を初期化子という
- 記憶域期間
  	- オブジェクト（変数）の生存期間
  	- 自動記憶域期間
  	  	- 関数内でstaticをつけずに定義されたオブジェクトに与えられる
  	  	- プログラムの流れが宣言を通過する際にオブジェクトが生成される。宣言を囲むブロックの終端である}を通過するとき、破棄される
  	  	- 初期化子が与えられずに宣言されると、初期値は不定値になる
  	- 静的記憶域期間
  	  	- 関数の外で宣言・定義されたオブジェクト、関数の中でstaticをつけて宣言されたオブジェクトに与えられる
  	  	- プログラムの開始時（main関数の実行開始前の準備段階で）オブジェクトが生成され、プログラムの終了時に破棄される
  	  	- 初期化子が与えられずに宣言されると、自動的に0で初期化される。プログラムの流れが宣言を通過するたびに初期化されるわけではない
  	  
- ローカル変数（局所変数）
  	- ブロック有効範囲を持ったもの
- グローバル変数（外部変数）
  	ファイル有効範囲を持ったもの

<details>
<summary>具体例</summary>

メイン関数の中で関数の引数に関数外の変数を指定していると、
関数に贈られる引数は関数外の変数の値になる
送られた先の関数の中に同じ名前の変数があっても、参照されるタイミングがメイン関数なので、関数外の変数が参照される
その後、送られた先の関数で関数外の変数の値が変えられても関係ない

```c
#include <stdio.h>
int x = 10, y = 20;

int func1(void)
{
    return x + y;
}

int func2(void)
{
    int x = 11;

    return x + y;
}

int func3(int y)
{
    x = 30;
    return x + y;
}

int main(void)
{
    printf("1:%d\n", func1());
    printf("2:%d\n", func2());
    printf("3:%d\n", func3(x + 2));

    return 0;
}
```
このプログラムでは、メイン関数でfunc3に引数を渡す際、「x + 2」は関数外の
xを参照するので「10 + 2」で「12」となる。関数func3で関数外のxの値が30に更新されるので、「30 + 12」で「42」となる

- メイン関数のprintfを下記のように書き換えると
```C
printf("3:%d\n", func3(x + 2));
printf("1:%d\n", func1());
printf("2:%d\n", func2());
```
実行順が変わり、func3の結果は変わらないが、func1で関数外のxを参照すると
値が変わっていて「30」になっているので「30 + 20」で「50」となる

</details>

- アドレス
  	- メモリ空間（記憶域）のどこにオブジェクトが格納されているのか、場所を表す番地
  
<details>
<summary>不定値</summary>
    
- 変数の値を設定しないと、変数名を宣言したときに、とりあえず作られたその変数名のための場所に、昔そこにあったデータが残っていて、それが代入されてしまう<br>
```c
printf("nの値は%dです。\n", n);
```
→出力結果<br>
> nの値は7です。<br>

　不定値（ゴミの値）<br>
　初期化せず、宣言だけした変数に、まだ代入していない状態で別の変数にその変数を代入しようとするとwarningが出るので避ける
  
</details>

- カウンタ用変数
	- 繰り返し文の制御に使う変数
   	- 多くの場合iやjが使用される
  
</details>

<details>
<summary>型</summary>
  
- 暗黙の型変換
	- 異なる型の変数同士で計算すると、勝手に一方の変数の型が格上げされ、同じ型同士の計算になる 
	- より大きくて小数部を格納できる型に変換される

- キャスト<br>
> （型）式

の形式で、式の型を（）の型に変更する

<details>
<summary>スカラ型</summary>
- 数量を扱う

<details>
<summary>算術型</summary>

<details>
<summary>列挙型</summary>

- 整数型
  
- enum型
	- エニューム・イニューム型と読む

</details>

<details>
<summary>基本型</summary>

<details>
<summary>char型</summary>

</details>

<details>
<summary>符号付き整数型</summary>

- signed char型
	- 文字型

- (signed) short (int)型
	- shortと省略可
	- int系型

- (signed) int型
	- intと省略可
	- int系型
	- 整数型      
	- 小数点以下の数は扱えない
	- int型で確実に表現できる値は-32767から32767まで<br>
	```c
	int x = 3.5;
	```
	
	　とすると、xに代入される値は3になる
	```c
	int x = 3.5; int y = x + 5.7;
	```
	　とすると、yに代入される値は8になる

- (signed) long (int)型
	- longと省略可
	- int系型

- (signed) long long (int)型
	- long longと省略可
	- int系型

<details>
<summary>符号無し整数型</summary>

- unsigned char型
	- 文字型

- unsigned short (int)型
	- unsigned shortと省略可
	- int系型

- unsigned (int)型
	- unsignedと省略可
	- int系型

- unsigned long (int)型
	- unusigned longと省略可
	- int系型

- unsigned long long (int)型
	- unsigned long longと省略可
	- int系型
  
</details>

</details>

<details>

<summary>浮動小数点型</summary>

- float型

- double型
	- 実数を浮動小数点数という形式で表す
	- double型はそのひとつ
	```c
	double x = 3.141592;
	printf("円周率は%fです。", x)
	```
	　→　出力結果
	> 円周率は3.141592です。
	
	- double型では小数点以下6桁まで表示される（5.2は5.200000となる）
    
</details>

- long double型
  
</details>

<details>
<summary>整数型</summary>

- 有限範囲の連続した整数
- 符号付き整数型(signed)
  	- 負/0/正を表現する整数型
- 符号無し整数型(unsignd)
  	- 0/正を表示する整数型
- int系型は、signed/unsigndと型指定子を与えなければ符号付き型とみなされる
- charは、単なるchar型、signd char型、unsigned char型の3つに分類される
- charのつく型は低い、int系型の中ではshortの方が低く、long longが最も高いと表現される
  
</details>

</details>

<details>
<summary>ポインタ型</summary>	
	
</details>

</details>

<details>
<summary>関数</summary>
  
- 第一引数の1番目の変換指定(%dなど)に1番目の第二引数の整数を、第二引数の2番目の変換指定(%d)に2番目の第二変数の整数を自動的に代入する
- 関数を実引数に指定することもできる
- 関数は**2個以上の値を返却できない**
- できれば、return文は1個だけにすること
- 関数が受け取る仮引数や、関数内で定義される変数はそれぞれの関数に独自のものなので実引数と仮引数の変数名が同じでも問題ない
- 呼び出した関数の仮引数に別の関数の返却値を入れることができる
- 返却値型と仮引数型並びはvoidにすることができる。その場合、呼び出し側でも()内は空にする

<details>
<summary>ライブラリ関数</summary>
	
- C言語で標準で提供される関数のこと

- main関数
  	- コマンドラインから入力された文字列をmain関数に引数として渡すことができる
  	  	- 入力された引数の数（実行モジュール名とそれ以降のargvの中身）　argc
  	  	- 入力された引数の内容（文字列）　argv
  	  	- `int main (int argc, char *argv[])`
  	  	- コマンドラインから「TEST AAAA BBBB CCCC」と入力して実行した場合、引数の内容は
  	  	  	- argc → 4
  	  	  	- argv[0] → TEST(実行モジュール名)
  	  	  	- argv[1] → AAAA
  	  	  	- argv[2] → BBBB
  	  	  	- argv[3] → CCCC
  		- main関数の返却値の型がint型なのは、作成されたプログラムをOSが呼び出すとき返却値がint型と想定しているから。通常はこの値はプログラム終了コードとして使われる
  	   　- argv[argc]は、入力された文字列の内容の後に「NULL」が入っている
  	- まず最初に動くのがmain関数
  	  ```c
  	  int main(void)
  	  {
  	      return 0;
  	  }
  	  ```

- printf関数
	```c
	int no = 5;
	printf(”%dに10を足した値は%dです。”, no, no + 10);
	```
 
- puts関数
	- 実引数として与えられた文字の並びを出力した上で改行文字を出力する
	- puts(”・・・”)はprintf(”・・・\n”)とほぼ同じ働きをする
	- puts関数は書式設定や数値の出力は不可能
  
<details>
<summary>scanf関数</summary>
    
- キーボードからの読み込みを行う関数
- ひとつの関数で複数入力させる場合は、値と値の間で改行・タブ・スペースのいずれかを使用する
- 読み取りに成功した項目の個数を返却する
  
```c
scanf("%d", &no);
```
　第一引数で変換指定、第二引数で読み込む<br>
　noは変数名。変数名の前に&をつける
```c
scanf("%d%d", &n1, &n2);
```
　n1が一つ目の%dに、n2は二つ目の%dに読み込みされる
    
</details>

</details>

<details>
<summary>関数の定義</summary>

```c
int max2（int a, int b)   // 関数頭部
{			　// |
if (a > b)		  // |
    return a;	          // 関数本体
else		          // |
    return b;	          // |
}		          // |
```
- 関数定義の構造
	- 関数頭部
   		- 関数の名前を含む仕様を記述する部分
      		- 返却値型（`int`の部分)
			- 関数が戻す値である返却値の型
     		- 関数名（`max2`の部分）
			- 関数の名前
    		- 仮引数型並び（`int a, int b`の部分）
       			- （）の中は補助的な指示を受け取るための変数である仮引数の宣言。通常の変数の宣言同様、型と変数名（仮引数名）を宣言
	- 関数本体
     		- 呼び出された際に実行する処理を記述した複合文
		- 関数の中でのみ利用する変数はこの複合文中で宣言、利用するのが原則
   		- 仮引数と同一名の変数は宣言できない
	   
</details>

<details>
<summary>関数呼び出し</summary>

- 最初はmain関数が実行されるので、main関数より先に定義した作成した関数が先に実行されることはない
- 関数呼出しが行われるとプログラム実行の流れはその関数に移る。main関数の実行が一時的に中断され、呼出された関数の実行が開始される
  	- その際に仮引数用の変数が生成されたうえで実引数の値が代入される
  	- 代入後に関数本体の複合文が実行される
  	- 関数本体の実行中にプログラムの流れがreturn文に出会うか、関数本体の末尾の}に到達すると、関数から抜け出して呼び出した場所に戻る
  	- 中断されていたmain関数の実行が再開される。戻る際の手土産がreturnの後ろに置かれた式の値。その返却値は関数呼出し式の評価で得られる
- 関数呼出し演算子
  	- 関数を呼び出す際に、関数名の後ろに置く()のこと
  	- この式のことを関数呼出し式という

- 再帰関数呼出し
  	- 関数の中で同じ関数を呼び出すこと
  	  
</details>
  
</details>

</details>

</details>

<details>
<summary>演算子</summary>
	
- 単項算術演算子 
	- 単項+演算子
		- +a<br>
  			aの値
		- 負の値を入力しても負の値のまま表示する
		- +をつけずにそのままの変数を実引数としても動作は同じ
	- 単項-演算子
		- -a<br>
			aの符号を反転した値
		- 負の整数を入力すると反転されるので、正の値が出力される    
- !演算子
  	- `! a`はaが0なら真、0でないなら偽を返す
- ~演算子<br>
    
オペランドを１個のみ必要とするのが単項演算子<br>
２個必要とするものは２項演算子<br>
３個必要とするものは３項演算子<br>
- 演算の優先度<br>
	- 数学と一緒で、式の中に（）があれば優先される
	- 加減算より乗除算が優先される

- 前置増分演算子・前置減分演算子
	- これらの演算子が使用された式の評価で得られる値は、インクリメント・デクリメント**後**の値になる。インクリメント・デクリメントされた後に値が出力される
		- `--no`の no に「5」を代入すると得られる値は
			>  4
   			　となる

- 後置増分演算子・後置減分演算子
	- 後置増分演算子
		- `a++`の形でオペランドの値を一つだけ増やす
   		- 値を一つだけ増やすことを**インクリメントする**という
	- 後置減分演算子
		- `a--`の形で、オペランドの値を一つだけ減らす
		- 値を一つだけ減らすことは**デクリメントする**という
	- "後置"は演算子をオペランドの後ろに置くことによるネーミング
	- オペランドと演算子の間にスペースを入れないこと
   	- これらの演算子が使用された式の評価で得られる値は、インクリメント・デクリメント**前**の値になる。値を評価した後にインクリメント・デクリメントされる
		- `while (no >= ) printf("%d" , no--)`の no に「5」を代入して実行すると
			「 5 4 3 2 1 0 」
   			　となる
   
   		- `printf("%d", ++i)`は、先にiの値に1プラスして、プラスした後の値を表示する
		- `printf("%d", --i)`は、プラスする前に評価（printf)されるので、先に元のiの値が表示されてからiの値に1プラスされ、表示はされないが値は増えている


- 代入演算子
	- 正式名称は単純代入演算子
	- =のこと

- 複合代入演算子
	- `a @= b`の形で、`a = a `bと基本同じ働きをする
   	- `a += 2`の場合、aの値に2を足した値に、aの値を更新する
   	- +=, -=, *=, /=, %=, <<=, >>=, &=, ^=, |= の10種類がある
   	- 演算を簡潔に表現できる
   	- 左辺の変数名を書くのが一回で済む
   	- 左辺の評価が一回限りである

- 等価演算子
	- どちらも等価演算子という
	- ==演算子
		- `==` で左右のオペランドの値が等しいか判定する
		- 等しければ 1、そうでなければ 0 という値を生成する
		- `=`は代入になるので使用しないこと
	- !=演算子
  		- 左右のオペランドが等しくないかどうか判定する
- 加減演算子
	- 加算 +
	- 減算 -
- 乗除演算子
	- 乗算 *
	- 除算 / (10÷2) = (10/2)
		| | 例 | x / y | x % y |
		----|----|----|----
   		| 正 ÷ 正 | x = 22, y = 5 | 4 | 2 |
   		| 負 ÷ 負 | x = -22, y = -5 | 4 | -2 |
   		| 正 ÷ 負 | x = 22, y = -5 | -4 | 2 |
   		| 負 ÷ 正 | x = -22, y = 5 | -4 | -2 |
	- 余り % （7÷3=2…1)（7 % 3 = 1)<br>
		- 文字列として`%`を表示するには`%%`と入力する
		- `整数 % 10` は最下位桁が出力される
    		- 0 % nは = 0。1 % nは = 1。割り算で1も立たないもの（左側の方が小さいもの）は左側の値がそのまま出てくる
  		

- 関係演算子
	- 二つのオペランドの大小関係を判定する演算子

- <演算子
	- 左が右よりも小さければ１，そうでなければ０（int型）
- \>演算子
	- 左が右より大きければ１，そうでなければ０（int型）
- <=演算子
	- 左が右以下であれば１，そうでなければ０（int型）
- \>=演算子
	- 左が右以上であれば１，そうでなければ０（int型）
<br><br>
<=演算子と>=演算子は逆向きにできない
差を出すときは&&や||を使うこと<br>

```c
if (3 <= a <= 5)　//誤：3つのオペランドは扱えない
```

```c
if (a >= 3 && a <= 5)　//正
```

<details>
<summary>条件演算子</summary>

> 式1 ? 式2 : 式3

1.　式1を評価。式1が非0であれば式2を評価した値となる<br>
2.　0であれば式3を評価した値となる<br>
- 唯一の3項演算子

```c
int max = n1 > n2 ? n1 :n2;
printf("大きいほうの値は%dです。\n", max);
```
　二つのプログラムは同じ結果が出力される
</details>

<details>
<summary>論理演算子</summary>

- 三つの変数が等しいかどうかを求めるときは
  `if ( a == b && b == c )`とする<br>
　`if ( a == b && c )`だと<br>
　aとbが等しいとき、True(1)になるので、1とcがFalseになる

- 短絡評価<br>
　&&演算子は、aを評価した値が0であればbの評価を行わない<br>
　||演算子も、aを評価した値が非0であればbの評価を行わない<br>

- 論理 AND 演算子

- `a && b`<br>
　a かつ b<br>
 
　論理積
| a | b | a && b|
----|----|---|
| 非0 | 非0 | ***1*** |
| 非0 | 0 | 0 |
| 0 | 非0 | 0 |
| 0 | 0 | 0 |

　両方ともTrue（非0）であれば 1<br>
 <br>

- 論理 OR 演算子

- `||`のこと
- `a || b`<br>
　a または b (a と bも含む）<br>
 
 　論理和
  | a | b | A \|\| b |
  |----|----|----|
  | 非0 | 非0 | ***1*** |
  | 非0 | 0 | ***1*** |
  | 0 | 非0 | ***1*** |
  | 0 | 0 | 0|
  
　一方でもTrue（非0）であれば 1
 

 - 論理否定演算子
	`! a`
	- オペランドが0と等しいかどうかを判定する演算子
	- ド・モルガンの法則
 		- 「各条件の否定をとって、論理積・論理和を入れ替えた式」の否定は、もとの条件と同じであるということ
		```c
  		a < 0 || a > 2
  		```
  		継続条件　aが不当な値であれば…
  		```c
    		!(a >= && a <= 2)
		```
    		終了条件の否定　aが妥当な値でなければ…
   		→　これは２つとも同じこと
   		- `x && y` = `!(!x || !y)`
		- `x || y` = `!(!x && !y)`
    		→　&&か||を反転
    		→　xとyを否定する形式に書き直す
    		→　全体に()をつけ、先頭に!をつける
    		↳　!をつける代わりに()の後に == 0 をつけ、Falese(0)にすることも可能

<details>
<summary>ビット単位の論理演算</summary>

- ビット単位のAND演算子
  	- `a & b`
  	- 両方とも真であれば真
  	- 論理積
  	  | a | b | a & y |
  	  ---|---|---
  	  0 | 0 | 0 |
  	  0 | 1 | 0
  	  1 | 0 | 0
  	  1 | 1 | 1

- ビット単位のOR演算子
  	- `a \| b`
  	- 一方でも真であれば真
  	- 論理和
  	  | a | b | a \| y |
  	  ---|---|---
  	  0 | 0 | 0 |
  	  0 | 1 | 1
  	  1 | 0 | 1
  	  1 | 1 | 1

- ビット単位の排他OR演算子
  	- `a ^ b`
  	- 一方のみ真であれば真
  	- 排他的論理和
  	  | a | b | a ^ y |
  	  ---|---|---
  	  0 | 0 | 0 |
  	  0 | 1 | 1
  	  1 | 0 | 1
  	  1 | 1 | 0

- ~演算子(補数演算子)
  	- `~a`
  	- aの1の補数（すべてのビットを反転した値）を求める
  	- x | ~x
  	  ---|---
  	  0 | 1
  	  1 | 0
  	  
</details>
</details>

<details>
<summary>シフト演算子</summary>

- <<演算子
  	- `a << n`
  	- aをnビット左にシフトする。空いたビットには0を埋める
  	- nが符号無し整数型であれば、シフト結果は a × 2ⁿとなる（左に1ビットシフトすると、値は2倍になる。10進数を左に1桁シフトすると、値が10倍になる（ex:196を左桁シフトすると1960になる）のと同じ理屈
  	- a << 2 は a × 2² なので、a × 4と同じになる
  	- 奇数のときは a × 5 と (a << 2) + a は同じ 

- >>演算子
  	- `a >> b`
  	- aをbビット右にシフトする。空いたビットには0を埋める
  	- bが符号無し整数型か、符号付き整数型の非負値であれば、シフト結果は x ÷ 2ⁿの商の整数部となる（右に1ビットシフトすると、値は1 / 2になる。10進数を右に1桁シフトすると、値が1 / 10になる（ex:196を右に1桁シフトすると19になる）のと同じ理屈
  	- 表示している範囲の外にずれたビットは消える

- >>演算子と<<演算子は整数中の全ビットを左または右にずらした値を生成する演算子
- まとめてビット単位のシフト演算子という
  
</details>

- 関数呼出し演算子<br>
	`x(arg)`<br>
	関数xに実引数argを渡して呼び出す。関数xが返却した値を生成する

- sizeof演算子
  	- char型が占有する1個の箱の大きさが1で、箱の中のビット数は最低でも8ビットとだけ決められており具体的なビット数は処理系任せ
  	- 他の型の箱の大きさは決まってないのでsizeof演算子で調べられる
  	- バイト数を生成する
  	- 符号無し整数型の値を生成するが、shortからlong longまでの4種類のどの型なのかは定められていない
  	  `sizeof (型名)`<br>
  	  とした場合、型の大きさを調べることができる<br>
  	  `sizeof 式` <br>
     　　　とした場合、変数や定数、式の大きさを調べることができる
  	  `sizeof(配列名) / sizeof(配列名[0])`
  	  配列の要素数を求める式

- コンマ演算子
  	```c
   	a, b
  	```
   	- aとbを順番に評価し、式全体としてbの評価値を生成
  	- aは評価だけが行われ、値は切り捨てられる。bの評価で得られる型と値がコンマ式a, b全体の型と値となる
  	  例：```c
  	      x = (++i, ++j);
  	      ```
  	      これを実行するとiとj両方がインクリメントされるが、xに代入されるのはインクリメント後のjの値だけになる

- アドレス演算子
  	- `&a`
  	- aのアドレス（aへのポインタを生成する）
  	- ポインタを生成する演算子
  	- アドレスを表示する変換指定は%p

- 間接演算子（単項*演算子）
  	- `*a`
  	- aが指すオブジェクトそのもの

<details>
<summary>演算子一覧</summary>

| 優先順位 | 演算子 | 形式 | 名称 | 結合性 |
---|---|---|---|-----------------------------
1 | () | x(y) | 関数呼出し演算子 | 左
1 | [] | x[y] | 添字演算子 | 左
1 | . | x . y | ドット演算子 | 左
1 | -> | x -> y | アロー演算子 | 左
1 | ++ | x++ | 後置増分演算子 | 左
1 | -- | x-- | 後置減分演算子 | 左
2 | ++ | ++x | 前置増分演算子 | 右
2 | -- | --x | 前置減分演算子 | 右
2 | sizeof | sizeof x | sizeof演算子 | 右
2 | & | &x | 単項&演算子（アドレス演算子） | 右
2 | * | *x | 単項\*演算子（間接演算子） | 右
2 | + | +X | 単項+演算子 | 右
2 | - | -X | 単項-演算子 | 右
2 | ~ | ~X | ~演算子（補数演算子） | 右
3 | ! | !x | 論理否定演算子 | 右
3 | () | (X)y |キャスト演算子 | 右
4 | * | x * y | 2項\*演算子 | 左
4 | / | x / y | /演算子 | 左
4 | & | x % y | %演算子 | 左
5 | + | x + y | 2項+演算子（加算演算子）| 左
5 | - | x - y | 2項-演算子（減算演算子） | 左
6 | << | x << y | <<演算子 | 左
6 | >> | x >> y | >>演算子 | 左
7 | < | x < y | <演算子 | 左
7 | <= | x <= y | <=演算子 | 左
7 | > | x > y | >演算子 | 左
7 | >= | x >= y | >=演算子 | 左
8 | == | x == y | ==演算子 | 左
8 | != | x != y | !=演算子 | 左
9 | & | x & y | ビット単位のAND演算子 | 左
10 | ^ | x ^ y | ビット単位の排他OR演算子 | 左
11 | \| | x \| y | ビット単位のOR演算子 | 左
12 | && | x && y | 論理AND演算子 | 左
13 | \|\| | x \|\| y | 論理OR演算子 | 左
14 | ? : | x ? y : z | 条件演算子 | 右
15 | = | x = y | 単純代入演算子 | 右
15 | += -= *= /= %= <<= >>= &= ^= \|= | x @= y| 複合代入演算子 | 右
16 | , | x , y | コンマ演算子 | 左

</details>
  	  
<details>
<summary>様々な演算子の評価</summary>

```c
int n = 51;

	printf("n > 0 : %d\n", n > 0);
	// n > 0 : 1
	// 「n > 0 : (10進数で)(第1オペランドの方が第2オペランドより大きい場合は"1"、そうでなければ"０"を表示する)」

	printf("n == 0 : %d\n", n == 0);
	// n == 0 : 0
	// 「n == 0 : (10進数で)(第1オペランドと第2オペランドが等しければ"1"を、そうでなければ"0"を表示する)」

	printf("n / 2 = %d\n", n / 2);
	// n / 2 = 25

	printf("n / 2.0 = %.1f\n", n / 2.0);
	// n / 2.0 = 25.5

	printf("n %% 2 = %d\n", n % 2);
	// n % 2 = 1

	printf("n - 2 = %d\n", n - 2);
	// n - 2 = 49

	printf("(int)5.7 : %d\n", (int)5.7);
	// (int)5.7 : 5

	printf("(double)5 : %.1f\n", (double)5);
	// (double)5 : 5.0
```
</details>

</details>
  
<details>
  <summary>オペランド</summary>
    
- 演算の対象となる変数や定数
- x + y のとき、xとyはオペランド、+は演算子という
- 左側のオペランドは第１オペランド/左オペランドという
- 右側のオペランドは第２オペランド/右オペランドという

</details>

</details>

<details>
<summary>配列</summary>

- 要素と呼ばれる同一型の変数が直線状に連続して並んだもの<br><br>

- 配列の宣言
 	 > 要素型 配列名\[要素数]
	- 要素型
   		- int型など特定の型で揃える型を指定する
       	- 配列名
       	  	- 変数名（識別子）
       	- 要素数
       	  	- 定数式にするのが原則
       	```c
        int a[5];
        ```
        - int型の変数を5個集めて作ったaという配列
   	- int/[5]型（intの5型）と呼称する
  	- この配列は
  	  	a\[0]<br>
  	  	a\[1]<br>
  	  	a\[2]<br>
  	  	a\[3]<br>
  	  	a\[4]<br>
  	　となっており、[]内のオペランドを添字と呼ぶ<br>
    	　先頭要素から何個後ろの要素なのかを表す（1個目は0になる）
    	　先頭要素は0からはじまるため、末尾要素は、要素数-1となる

- 配列の初期化
	- `型 配列名[要素数] = {要素1, 要素2, ...};` の形式で初期化できる
	- 配列の初期化子の最後にも , を置ける
	- 要素数を指定しない場合、初期化子の個数に基づいて配列の要素数が自動的に決定される
	  - 例: `int a[] = {1, 2, 3};` は要素数が3になる
	  - ただし、宣言のみで初期化を行わない場合は必ず要素数が必要
	- 要素数分の初期化子が与えられていない場合、足りない分の要素は0で初期化される
	  - 例: `int a[5] = {1, 2};` は要素が `1, 2, 0, 0, 0` となる
	  - ただし、`{}` を使用しひとつも要素を入れないと不定値で初期化される
	- 初期化子の個数が配列の要素数を超えるとエラーになる
	  - 例: `int a[3] = {1, 2, 3, 4};` はエラーとなる
	- 初期化子を使った代入はできない
	  - 例: 
	  ```c
	  int a[3];
	  a = {1, 2, 3}; // エラー
	  ```
	  - 以下のように1つずつ代入する必要がある:
	  ```c
	  a[0] = 1;
	  a[1] = 2;
	  a[2] = 3;
	  ```
- 配列の走査
  	- 添字式
  	  	- 配列の要素へのアクセスは添字演算子\[ ]を使った添字式を使う
  	  	  	- `a[3]++;`はaというリストの添字3の値に1足すということ
  	- 配列の要素を一つずつ順番になぞっていくことを走査と呼ぶ
  	- for文での書き方
  	  	```c
  	   	for (int i = 0; i < 5; i++)
  	   	    a[i] = i +1;

  	   	for (int i = 0; i < 5; i++)
  	   	    printf("a[%d] = %d\n", i, a[i]);
  	   	```
  	   	>実行結果
  	    	>a\[0] = 1
  	    	>a\[1] = 2
  	    	>a\[2] = 3
  	  	>a\[3] = 4
  	    	>a\[4] = 5
  	    	変数iに添字が代入され、iに1ずつ足していく<br>
		a\[i] = i + 1とすることで1から順に各添字の要素にしていく
- 要素を交換する
	- 直接は交換できないので、余分な変数を用意し、3つで2つを循環すれば2値を交換できる

- 代入式の評価
  	- 代入式を評価して得られるのは代入後の左オペランドの型と値
  	- 代入は右側から行われる<br>
   	`min = max = tensu[0];`は<br>
    	`min = (max = tensu[0]);`と同じ
  	  minとmax両方にtensu[0]の値が代入される
  	  	- `a = b = 0`は「変数aとbの両方に0を代入する
  	  	- 初期化の宣言には適用されない

- 配列のコピー
  	- 配列の直接代入はできないため、繰り返し文などを用いる

- 多次元配列
  	- 配列の要素が配列であるもの
  	- 配列を要素型とするのが2次元配列
  	- 2次元配列を要素型とするのが3次元配列
  	- 2次元以上の配列の総称が多次元配列
  	- 要素型が配列ではない配列は1次元配列と呼ばれる
  	- 多次元配列の宣言では最初にまとめる要素数（2次元配列の場合は列数）を末尾側に置く
  	- 各要素にアクセスする添字式は`a[i][j]`という形式
  	- まず末尾側の添字が順に0,1...と増えていき、それから先頭側の添字が0,1...と増えていく
  	  	  `a[0][0]` → `a[0][1]` → `a[0][2]`
  	  	→ `a[1][0]` → `a[1][1]` → `a[1][2]`
  	  	→ `a[2][0]` → `a[2][1]` → `a[2][2]`
  	  - 3次元配列の添字式は\[ ]が3つ並ぶ形になる<br>
  	    	```c
  	    	void func1(int v[],	  int n);
  	    	void func2(int v[][3],	  int n);
  	    	void func3(int v[][2][3], int n);
  	    	```

<table>
<tr>
<td><img width="200" height="204" alt="Image" src="https://github.com/user-attachments/assets/ebc17974-5f1a-4e1b-b6d2-bd12c6dee986" /></td>
<td><img width="200" height="204" alt="Image" src="https://github.com/user-attachments/assets/c4e47958-8551-4fac-9857-35a97d158372" /></td>
<td><img width="200" height="204" alt="Image" src="https://github.com/user-attachments/assets/0c3dd64f-6183-4363-90d4-5091b84b3f26" /></td>
</tr>
</table>

- 2次元配列
1. int型を3個まとめて1次元配列を派生
1. 1次元配列を4個まとめて2次元配列を派生
<br><br>
2次元配列は要素が縦横に並んで行と列で構成される表のイメージ
縦に4個、横に3個要素が並んでいる2次元配列は「4行3列の2次元配列」と呼ばれる

- 線形探索（逐次探索）
  	- 配列内を検索できる
  	- 探索は配列の要素を先頭から順に走査することで行う
  	- 番兵法
  	  	- 探索する配列の最後に探す値を格納しておくと、必ず最後に探している要素が見つかるので負荷が減る
  	  	  - 最後の値だった場合は番兵であるとわかる
  	  	  - 末端に追加したデータを番兵と呼ぶ

</details>

<details>
<summary>列挙体</summary>
- 列挙体
	- 関数外で列挙体の宣言
 	- `enum 列挙体タグ { 列挙定数a, 列挙定数b, 列挙定数c, … Invalid };`
  	- 列挙定数には指定がなければ、先頭が0で、そこから連番の整数値が与えられる
	- この数字が値になる
   	- Invalidはなくても問題ないが、あるとプログラムの書き換えが少なくて済む
	
- 列挙体を使った変数の宣言
	- `enum 列挙体タグ` 変数名;`
 	- enum + 列挙体タグで型名となる
	- 宣言はメイン関数内で行う


- 列挙定数
	- 数字を指定しないと、0から1ずつ増えた数が割り当てられる
   	- `a = 0`とすると、aの列挙定数は0となり、aの次の列挙定数の数字は、指定しなくても1となる
   	- 0からはじめなくてもよい。最初の列挙定数を`= 1`などにすれば、1からはじめることができる
   	- 連番でなくてもよい。`{ a, b = 5, c }`とすると、aの数字は0、bは5、cは6となる
   	- 同じ数字を複数の列挙定数に与えることも可能。`{a, b
</details>

<details>
<summary>構造体</summary>

- 複数のデータで構成されるカード形式のデータを表すことができる
- ```c
  struct 構造体タグ {
      型 変数名;
      型 変数名;
      型 変数名;
  };```
- ex:<br>
  ```c
  struct student {
      char name[64]; // 名前
      int height;    // 身長
      double weight; // 体重
  };
  ```
- studentが構造体の名前で、構造体タグと呼ばれる
- name, height, weightは構造体のメンバ
- 作成した構造体を利用するオブジェクトの宣言は
	- `struct 構造体タグ 変数名;`
	- ex:`struct student tanaka;`のように行う
- 構造体の宣言とその型のオブジェクトの宣言を同時に行うこともできる
	-  ```c
       struct student {
           char name[64]; 
           int height;    
           double weight; 
  	   } tanaka, yamada;
       ```
- オブジェクトの初期化でメンバの値を一緒に宣言することもできる
  	- `struct student tanaka = {"Tanaka", 175};`
  	- name, height,weightのメンバに初期化子が順番に入っていく
  	- weightの分の初期化子がないので、0で初期化される。この場合tanakaのweightは0.0として初期化される

- .演算子（ドット演算子）
  	- `a . b`
  	- 構造体aのメンバbを表す
  	- この形で構造体の個々のメンバにアクセスが可能
 
</details>

<details>
<summary>ポインタ</summary>
- `int *p = &n`
- 変数pの型は「int型オブジェクトへのポインタ型」という
	- 長いので「intへのポインタ型」「int *型」と呼ぶのが一般的
- ポインタpの値がnのアドレスであるとき「pはnを指す」という
- エイリアス
	- 「式*pがnそのものを表す」ことを「*pはnのエイリアスである」と表現する
- 参照外し
	- ポインタに間接演算子を適用することでポインタが指すオブジェクトを間接的にアクセスすること
- 関数にアドレスを渡すのが2回目以降の"たらい回し"である場合、&をつけずに渡さないと橋渡しをしている変数のアドレスを参照してしまう
- 空（くう）ポインタ
	- 何も指さないことが保証されている
 	- オブジェクト形式マクロでNULLは空ポインタ定数という名称
  	- <stddef.h>、<stdio.h>、<stdlib.h>、<string.h>、<time.h>のどれをインクルードしても取り込める

- 配列とポインタ
  	- ポインタで配列名を指定するとその配列の先頭要素へのポインタと解釈される
  	- ```c
  	  int a[5];
  	  int *p = a;
  	  ```
  	  とすると、pはa[0]を指す
  	  `p + i`はa[i]のポインタになる
  	- ポインタと配列の表記上の可換性
  	  	- Type型配列aの先頭要素a[0]を、Type*型ポインタpが指すとき、ポインタpはあたかも配列aそのものであるかのようにふるまう
  	- 配列の先頭からi個後ろの要素へアクセスする式
  	  	- `a[i]` `*(a + i)` `p[i]` `*(p + i)`
  	- 配列の先頭からi個後ろの要素へのポインタ
  	  	- `&a[i]` `a + i` `&p[i]` `p + i`
  	- 関数間での配列の受け渡しは先頭要素へのポインタとして行う<br>
  	  呼び出された関数では受け取ったポインタが、呼び出し側が渡した配列そのものであるかのうようにふるまう<br>
          やりとりするのが配列そのものではなく単なるポインタであるため要素数は別の引数として受け渡しする必要がある
  	- 配列を関数に渡す際、main関数では配列の形で記述し、配列名を関数呼び出しの引数として渡しても、呼び出された関数側の引数ではポインタの形で記述が可能
  	  	- ```c
  	  	  void put_string(const char *s)
  	  	  {
  	  	      while(*s) {
  	  	  	 putchar(*s++);
  	  	      }
  	  	  }

  	  	  int main(void)
  	  	  {
  	  	      char str[] = "ABC";
  	  	      put_string(str);
  	  	  }
  	  - ポインタによる文字列の配列
  	    	- `char *p[] = {"ABC", "DEF", "GHI"};`
  	    	- pはchar *型のポインタを3個集めた配列
  	    	- 配列の要素p[0]、p[1]、p[2]は各文字列リテラルの先頭文字'A'、'D'、'G'へのポインタで初期化されている
  	    	- 文字列リテラル"ABC"内の文字は、先頭から順にp[0][0]、p[0][1]…でアクセスできる
  	    	- 配列による文字列の配列はすべての要素が連続して配置されることが保証されるが、ポインタによる文字列の配列は文字列と文字列が並んでいる保証はない（'A'と'B'は並んでいるが、"ABC"の末尾の'\n'と'D'は並んでいる保証がない）
		
</details>

<details>
<summary>指令</summary>
	
- \#include指令
   	- ヘッダを取り込むときに使う
       	- この指令を使うことをインクルードするという
           
- \#define指令
  	- オブジェクト形式マクロを定義するための特殊な宣言<br>
  	`#define a b`
  	 という形式で「この指令以降のaをbに置換せよ」という命令
  	aは**マクロ名**と呼ばれる
	マクロ名は変数名と区別しやすくするため大文字とする慣習がある
- マジックナンバー<br>
プログラムに直接書かれた5や8などの定数
何を表す数値なのかよく分からない数という意味
文字列リテラルや文字定数内の綴りや変数名などの識別子の一部としての綴りは置換の対象外

<details>
<summary>ヘッダ</summary>

- <stdio.h>
  	- FILENAME_MAX
  	  	- <stdio.h>ヘッダで定義されるオブジェクト形式マクロ
  	  	- その処理系でオープン可能であると保証されるファイル名の最大長を保持するのに必要な配列の要素数
	  
- <limits.h>
	- 各型で表現できる最小値と最大値が提供される

- <time.h>
  	-日付と時刻
  	- time_t型
  	  	- 暦時刻
  	  	- long型やdouble型などの加減乗除が可能な算術型
  	- time関数
  	  	- 現在時刻を暦時刻で取得
  	  	- 求めた暦時刻を返却値として返し、引数が指すオブジェクトにも格納する
  	- tm構造体
  	  	- 要素別の時刻
  	  	- 日付や時刻に関する要素をメンバとして持つ
  	- localtime関数
  	  	- 暦時刻から地方時要素別の時刻への変換

- <stddef.h>
	- typeof宣言
		`typedef 既存の型名 別名;`
   		- この宣言で新しく作られた名前はtypedef名と呼ばれる
       		- sizeof演算子で生成される値の型はどの処理系でもsize_t型と表記されるようにtypeof宣言が<stddef.h>ヘッダ内で定義されている
         - EOFは<stdio.h>内でオブジェクト形式マクロとして、負の値になるように定義されている

- <ctype.h>
  	- toupper関数
  	  	- int toupper(int c)
  	  	  	- 英小文字を英大文字に変換。英小文字でなければそのまま返却
  	- tolower関数
  	  	- int tolower(int c)
  	  	  	- 英大文字を英小文字に変換。英大文字でなければそのまま返却
  	- isalnum関数（イズアルナム）
  	  	- 引数が英数字なら真、違うなら0を返す
  	- isalpha関数（イズアルファ）
  	  	- 引数が英文字なら真、違うなら0を返す
  	- isdigit関数（イズディジット）
  	  	- 引数が数字なら真、違うなら0を返す
  	- isupper関数
  	  	- 引数が大文字なら真、違うなら0を返す
  	- islower関数
  	  	- 引数が小文字なら真、違うなら0を返す
  	- isxdigit関数
  	  	- 引数が16進文字で使用される文字(0～9,a～f,A～F)なら真、違うなら0を返す
  	- isspace関数
  	  	- 引数が空白、改行、水平タブ、垂直タブ、復帰、フォームフィード(0x09～0x0D,0x20)なら真、違うなら0を返す
	- isprint関数
   		- 引数が印刷可能文字(0x20～0x7E)なら真、違うなら0を返す
  	- isgraph関数
  	  	- 引数が空白を除く印刷可能文字(0x21～0x7E)なら真、違うなら0を返す
  	- ispunct関数
  	  	- 引数が区切り文字なら真、違うなら0を返す
  	  	- 区切り文字とは、isalnum関数が偽を返す文字であり、かつ、図形文字（＝isgraph関数が真を返す）でもあるものを指す
  	  	- つまり記号
  	- iscntrl関数
  	  	- 引数が制御文字0x00～0x1f、0x7f)のとき真、違うなら0を返す
  	  	  
   	- isprint()とisgraph()とispunct()で印刷可能文字とされる記号一覧
   	  	- ! " # $ % & ' ( ) = ~ |<br>
       		  ` { + * } < > ? _<br>
   	  	  - ^ @ [ ; : ] , . / \
   	- 制御文字でエスケープシーケンスがあるもの
   	  	- 0x00 \0
   	  	- 0x07 \a
   	  	- 0x08 \b バックスペースで直前の文字が1文字消えるはずだが消えない
   	  	- 0x09 \t 水平タブ
   	  	- 0x0a \n 改行
   	  	- 0x0b \v 垂直タブ
   	  	- 0x0c \f フォームフィード
   	  	- 0x0d \r キャリッジリターン
   	  	- 0x0e \x エスケープシーケンス
   	  	- 0x17 ETB
   	  	- 0x1b \e エスケープ
   	  	  
</details>

<details>
<summary><string.h>ヘッダ</summary>

- 文字列関連のライブラリが多く入っている

- strlen関数（ストラレン）
  	- 指定された文字列の、ナル文字を含まない長さを返す
  	- `strlen(str)`
  	- size_t型で定義されているので%zuで表示する

- strcpy関数（ストラコピー）
  	- 文字列をコピーする関数
  	- `strcpy(s1, s2);`
 		- s2が指す文字列をs1が指す配列にコピーする
	- strncpy関数
   		- コピーする文字数に制限を設けたいときはこちら
       		- `strncpy(s1, s2, n);`
           		- s2が指す文字列をs1が指す配列にコピーする。s2の長さがn以上の場合はn文字までをコピーし、nより短い場合は残りをナル文字で埋め尽くす
               	- コピー元文字列s2の長さがn以上の場合、ナル文字をコピーしないので、コピー先配列の n + 1 がナル文字でないとバグを生みかねない
               	  	- ```c
               	  	  char s1[5];
			  char *s2 = "12345";
			  strncpy(s1, s2, 3);
			  printf("%s\n", s1); // 実行結果 123□h
			  ```
               
- strcat関数（ストラカット）
  	- 文字列を連結する関数
  	- `strcat(s1, s2)`
  	- s2が指す文字列を、s1が指す文字列の末尾に連結する
  	- s1の文字列の後ろの領域が開いていないと連結できない
	- s1の\n部分からコピーがスタートする。s2の\nまでコピーされる
	- strncat関数
   		- 連結する文字数に制限を設ける場合使う
       	  	- `strncat(s1, s2, n)`
          	- s2が指す文字列を、s1が指す文字列の末尾に連結する。s2の長さがnより長い場合は切り捨てる
          	- 何文字を指定してもn + \nが連結される
          	  
- strcmp関数（ストラコンプ）
  	- 二つの文字列の大小関係を判定する
  	- `strcmp(s1, s2)`
  	- s1が指す文字列とs2が指す文字列の大小関係（先頭から順に１文字ずつunsigned char型の値として比較していき、異なる文字が出現したとき、それらの文字の対に成立する大小関係とする）の比較を行う
  	- どちらかの文字列にナル文字が出現するとそれ以降は比較しない。どちらかにナル文字が出現する直前までの長さの文字列同士を比較する
  	- 等しければ`0`、s1が大きければ正の整数値、s2大きければ負の整数値を返す
	- strncmp関数
  		- s1が指す文字列とs2が指す文字の先頭n文字までの大小関係の比較を行う。ナル文字以降の文字は比較しない
      	- strcmp()は文字列でないといけないが、strncmp()はどちらもナル文字のない形の配列でも実行できる
      	  
- strchr関数
  	- 第1引数の文字列の先頭から、第2引数の文字を探し、最初の見つけたものの位置を返す
  	- `strchr(str, `a`)`
  	- strrchr関数
  	  	- 文字列の後ろから文字を探す
  	  
- strstr関数
  	- 第1引数の文字列の先頭から、第2引数の文字列を探し、その位置のポインタを返す。

</details>

<details><math.h></details>

- ceil関数
  	- 小数点以下の数値を切り"上げ"る
  	- `ceil(整数)`

- floor関数
  	- 小数点以下の数値を切り"下げ"る
  	- `floor(整数)`

- pow関数
  	- xのy乗を計算する
  	- `pow(x, y)`

- sqrt関数
  	- 平方根の値を返す
  	- 平方根は、2乗するとある数になる数のこと
  	- `sqrt(a)`

<details>
<summary><stdlib.h></summary>

- 他のヘッダに属さなかったライブラリの寄せ集め

- atoi関数
  	- 文字列をint型に変換
  	- `atoi(数字の文字列)`

- atof関数
  	- 文字列をdouble型に変換
  	- `atof(数字の文字列)`
  	  
- abs関数
  	- 引数の絶対値（0からその数までの距離）を返す
  	- `abs(int型整数)`

- rand関数
  	- 0～RAND_MAXまでの整数の疑似関数を返す
  	- RAND_MAXはstdlib.hの中で定義されている

-srand関数
	- 疑似乱数の発生系列を変える

- sqrt関数
  	- 平方根を計算する
    - `sqrt(a)`

</details>

</details>

- オブジェクト形式マクロ
  	- 選択的な置換

- 関数形式マクロ
  	- どの型にも関数のような指示を適用できる
  	- 文は1つだけ定義
  	  
  	`#define マクロ名(仮引数名) 文`
   
   	例：`#define a(x) ((x) * (x))`
   
   	- マクロ名と(の間に空白を入れてはいけない
   	- マクロの副作用
   		- 展開後の式が複数回評価されることで予期しない結果が生じる場合がある
   	- 引数なしの形式でも定義可能
   		- 例：`#define alert() (putchar('\n'))`
    
   	- 複数の式をマクロに含める場合、コンマ演算子で結んで1つの式にすることが可能（文にはしない）
  	  
</details>

<details>
<summary>文字列</summary>
	
- 一連の文字の並びを表すもの
- printf, scanfで文字列を表示する変換指定子は%s
- 文字配列は配列名で%d,%x,%oするとポインタになってしまう
- %sは配列内の最初の\0表示する
- 文字列は必ず配列
- 最初の\0までが文字列
- \0も含めて文字列
- 配列によって初期化された文字列(`char str[10];`)の中身を後から入れたい場合、strcpy関数を利用する(`strcpy(str, "ABC");`)のが便利
- ポインタで初期化された文字列(`char *str;`)には代入(`str = "ABC"`)が可能
  
- 空文字列
  	- 文字列の文字数は0個でもよい
  	- そうした文字列を空文字列という
  	- `char ns[] = "";`と宣言できる
  	- ナル文字だけが格納されるので要素数は0ではなく1
  	  
- 文字列リテラル（文字列定数）
	- "ABC"のような文字の並びを " で囲んだもの
   	- 定数なのに書き換えられるように見えるが、コードに直接書かれた"ABC"の部分はコンパイル時にメモリに格納されるが、配列はプログラム実行中に配列に入れられて、それはコンパイル時に格納した"ABC"のコピーでしかない
   	- 文字列リテラルはポインタである。初期化子として使われる場合は特例として内部で一文字ずつ代入される
   	- printf関数などの引数として書かれた""の中身も文字列リテラルとしてメモリに格納されている。printf関数で表示する際は%dなどの書式指定子に第2引数以降の引数が表示される仕組みだが、これは表示される際に一時的にすべての引数を連結させているだけで、実際に表示される文字が文字列リテラルとしてメモリに格納されるわけではない
	- ナル文字
		- 末尾についている見えない文字
		- ナル文字は値0
		- "と"の間に置かれた文字の並びの後ろにナル文字がくっついた状態で記憶域に格納される
    		- printf()内の""内の文字のように変えられない文字が多い
    		- 文字列とみなされるのは最初に出現するナル文字まで。そのあとは文字列とみなされないが、そのあとの文字も合わせて文字列リテラルという
		- 見かけ上の文字数+1分の記憶域を占有する<br>
		例："ABC"　    &nbsp;&nbsp;&nbsp;&nbsp;|A|B|C|\0|　     &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4文字分<br>
		　　""　　        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|\0|&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;0文字分<br>
		　　"AB\tC"    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|A|B|\t|C|\0| &emsp;&emsp;&nbsp;5文字分<br>
		　　"abc\0def" |a|b|c|\0|d|e|f|\0| &nbsp;8文字分
- 文字列の初期化（配列）
  	- `char str[4] = {'A', 'B', 'C', '\0};`
  	- `char str[] = "ABC";`でも構わない

- 文字列の初期化（ポインタ）
  	- `char *ptr = "ABC";`
  	- 書き換えができないことが多い（処理系に依存する）
  	- ポインタによる文字列は配列による文字列より多くの記憶域を必要とする
  	- *ptrは文字列リテラル"ABC"の先頭文字'A'を指す
  	- `char *ptr = {'A', 'B', 'C', '\0};という宣言はできない
  	  	- {}の初期化子は、単一の変数に適用できないため
  	  	- ただし文字列の配列はポインタで実現可能

</details>

<details>
<summary>ストリーム</summary>

- ストリーム
  	- 入出力されたデータを読み取る流れのこと

- 標準ストリーム
  	- stdin
   		- 標準入力ストリーム
  	    	- キーボードであることが多い
  	- stdout
  	  	- 標準出力ストリーム
  	  	- ディスプレイ画面であることが多い
  	- stderr
  	  	- 標準エラーストリーム
  	  	- エラーを書きだすストリーム
  	  	- ディスプレイ画面に割り当てられていることが多い

- FILE型
  	- FILE型オブジェクトへのポインタ型（FILE *型）
  	- <stdio.h>ヘッダで定義されている
  	- ストリームの制御に必要な情報を保存するための型
  	- ファイル位置表示子
  	  	- 現在アクセスしているアドレスを記録する
  	- エラー表示子
  	  	- 読み取りエラーまたは書き込みエラーが起こったかどうか記録する
  	- ファイル終了表示子
  	  	- ファイルの終わりに達したかどうかを記録する

- ファイルのオープン
  	- プログラムを利用する際に最初に開く操作をオープンという
  	- fopen関数
  	  	- ファイルのオープンに使う
  	  	- `ストリームの変数 = fopen("ファイル名", "モード");`
  	  	- ex: `fp = fopen("abc.txt", "r");`
  	  	- fopen関数は、オープンするファイル用のストリームを準備して、そのストリームの制御のための情報を格納するFILE型オブジェクトへのポインタを返す
  	  	- ファイルをオープンした後は、そのFILE *型のポインタを通じて、ストリームに対する指示を行う
  	  	- オープンに失敗したときは、空ポインタを返す
  	  	- モード
  	  	  	- r
  	  	  	  	- テキストファイルを読み取りモードでオープンする
  	  	  	- w
  	  	  	  	- テキストファイルを書き込みモードで生成するか、長さ0で切り捨てる
  	  	  	- a
  	  	  	  	- テキストファイルをファイルの終わりの位置からの書き込みモードでオープンまたは生成する

- ファイルのクローズ
  	- ファイルの利用終了時に、ファイルとストリームの結びつきを切り離してストリームを破棄する
  	- fclose関数
  	  	- ファイルのクローズに使う
  	  	- 引数は"fopen関数の戻り値"を指定する		
  	  	- `fclose(ストリームの変数）;`
- fscanf関数
  	- 標準入力ストリームではなく、第1引数で指定したストリームから読み取る。それ以外はscanf関数と同じ
  	- `fscanf(fp, "%d", &x);`

- fprintf関数
  	- 標準出力ストリームではなく、第1引数が指定するストリームに書き込む。それ以外はprintf関数と同じ
  	- `fprintf(fp, "%d", x);`

- fgetc関数
  	- 第1引数が指定するストリームから文字をunsigned char型の値として読み取り、int型に変換する。そしてそのストリームに結びつけられているファイル位置表示子を進める
  	- `fgetc(ストリーム名)`

- fputc関数
  	- 第2引数に指定したストリームに、第1引数の文字を、unsignes char型に変換して書き込む。書き込んだらファイル位置表示子を適切に進める
  	- `fputc(文字, ストリーム名)'

- fwrite関数
  	- 
  	  
</details>

<details>
<summary>キーワード</summary>

- 特別な意味が与えられた37の語句
- これらは変数などには使用できない
	- auto
 	- break
    	- case
       	- char
       	- const
       	- continue
       	- default
       	- do
       	- double
       	- else
       	- enum
       	- extern
       	- float
       	- for
       	- goto
       	- if
       	- inline
       	- int
       	- long
       	- register
       	- restrict
       	- return
       	- short
       	- signed
       	- sizeof
       	- static
       	- struct
       	- switch
       	- typedef
       	- union
       	- unsigned
       	- void
       	- volatile
       	- while
       	- _Bool
       	- _Complex
       	- _Imaginary
  
</details>

<details>
<summary>ソート</summary>

- 何らかの基準を設け、データの集まりを並び替えること
- パス
- 2つずつ比較して、順番に値を交換していくこと
- バブルソート
  	- 隣り合わせの値と比較して交換を繰り返していくソート
  	- リストの要素を昇順にソート
  	```c
   for (int i = n - 1; i > 0; i--) {
	    for (int j = 0; j < i; j++) {
	        if (a[j + 1] < a[j]) {
	            int temp = a[j];
		     a[j] = a[j + 1];
		     a[j + 1] = temp;
               }
         }
   }
   	```
   	- 外側のfor文では、ソートするリストの要素数`-1`を`i`に代入している。ソートに必要な繰り返し回数は要素数-1。内側のfor文で先頭から順に見ていき、一周するごとに比較する数が-1される必要があるので、`i`の値は要素数-1からデクリメントしていく
   	- 内側のfor文では、`0`から@i - 1`までの要素を比較している。先頭から見ていき、`j`を0とし、`j + 1`と比較する。もしより先頭側である`a[j]`の方が大きければ、昇順にソートするために入れ替える必要がある。その場合、2値の交換で入れ替える。`a [j + 1]`と比較していくので、`j`は、今のループで比較する要素数の最大値である`i`未満である必要があるので、内側のfor文の条件式は`j < i`の間となる。

 </details>
 
- 記憶域クラス指定子
  	- static
  	  	- 関数の中でstaticをつけて宣言されたオブジェクトには静的記憶域期間が与えられる
  	- auto
  	  	- 関数の中でautoをつけて宣言されたオブジェクトには自動記憶域期間が与えられるが、autoをつけなかった場合も自動記憶域期間が与えられるのでつけてもつけなくても同じである

- プログラム
  
　人が読めるもの　コンピュータが理解できるもの<br>
　ソースプログラム　→　実行プログラム<br>
　　　　　　　 コンパイル

- C言語は特定の計算機のアーキテクチャと関わりはあるが、異なるハードウェアで動作させることのできる移植可能なプログラムを書ける
- アセンブリ言語とは、機械がすぐ理解できる言語のこと。C言語はアセンブリ言語から発展して生まれた
  
- 自由形式
  	- 原則、自由な位置にプログラムを記述できる
  	- 制限
  	  	- 単語の途中に空白類文字（空白、タブ、改行）を入れてはいけない
  	  	- 前処理指令（`#`ではじめるもの）は原則１行で記述しないといけない
  	  	- 文字列リテラルや文字定数の途中で改行してはいけない
  	  	  	- 空白類文字やコメントをはさんで隣接している文字リテラルは連結される

- インデント
  	- 段落をインデント（段付け/字下げ）という
  	- インデントを用いて記述するとインデンテーションという

- 式文
	- 式の末尾に`;`がついて文という形になる
	- 式の後ろに`;`を置いた文は式文という
   	- for文やif文の制御式の後ろに`;`を置いてしまうと、`;`だけが文と認識されてプログラムがうまく動かなくなることがある
   	- `;`だけの文が空文という式文になる

- 宣言
  	- extern
  	  	- 宣言の先頭にexternを置くと別の場所で定義されているものを使うという意味で、ファイル有効範囲が与えられているものの場合は省略可能
  	- 関数原型宣言
  	  	- 本来、main関数を最後に置くが、main関数を上に置きたい場合、関数原型宣言だけmain関数の前に置いておけば、関数の定義はmain関数の後で構わない。関数頭部の末尾に;を置く


- コメント
	- 伝統的コメント
 		- `/*・・・*/`
		- 行の先頭や末尾でなくてもよい
		- 複数行にまたがることができる
		- `*/`で閉め忘れると大変なことになる
  
	- 行末コメント    
		- `//・・・`
		- //から行末までがコメント
		- 開始は行の先頭でなくてもよい
  
	- 入れ子
		- 可能な入れ子    
			 `/*・・・//・・・*/`
			 `//・・・/*・・・*/`
		- 不可能な入れ子<br>
			 `/*・・・/*・・・*/・・・*/`
      
- 引数
    
>仮引数　実引数<br>
printf("こんにちは");<br>
関数

<br>

- 値渡し
- 参照渡し
	- 配列の値は渡された側で変更すると、渡した側の値も変わる
- const型修飾子
	- 値が変更されることを防ぐ

- 処理系
	- コンパイル方式
		- ソースコードをコンピューターが直接理解・実行できる形式に翻訳する方式
  
	- インタプリタ方式
 		- ソースコードをコンピューターがプログラムを一行ずつ解釈しながら実行する方式

- テキストファイル
  	- データを文字の並びで表現する。整数値357は文字'3','5','7'の並びになり、printf関数などでこの値を画面に書き込むと3バイトになる
  	- 文字数が数値の桁数に依存する

- バイナリファイル
  	- データをビットの並びで表現する。処理系によってビット数が異なるが、int型整数値は必ずsizeof(int)になる

- 定数
	- 変数だけでなく、プログラムに埋め込まれた定数にも型がある
   	- 定数は書き換えられないもの
	- 整数定数<br>
  		5や37など。基本的にint型
   		- 整数定数は10進定数、8進定数、16進定数の3つの基数がある
       		- 8進定数は10進定数と見分けられるよう先頭に0を追加して表記する
 		- 16進定数は先頭に0xまたは0Xを置いて表記
     		- 16進定数ではA～Fも数字として扱う
         	- %xや%oで表示すると数字の頭に0や0xがつかないパッと見10進数に見える
 
     	- 8/16/2進数 → 10進数の変換<br>
   		１２３(8)<br>
		 8²&thinsp;8¹&thinsp;8⁰　&emsp;&emsp;&emsp;&emsp;&nbsp;小さい桁からn進数の、nの0乗、1乗、2乗…と重みを出していく<br>
  		↓&ensp;&thinsp;↓&ensp;&thinsp;↓<br>
    		64&thinsp;8&nbsp;1　&emsp;&emsp;&emsp;&emsp;&emsp;nのn乗と（0乗はすべて1となる）<br>
                ×&thinsp;&thinsp;×&thinsp;×<br>
		1 2  3  &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;と各桁の数を掛け算する<br>
               64+16+3 = 83　　すべて足すと10進数になる
        - 10進数 → 2/8/16進数に変換<br>
	１６）５７&emsp;&emsp;&emsp;&emsp;&emsp;変換したい数で割り、横に余りを書いていく<br>
 	&emsp;&emsp;￣￣￣&emsp;&emsp;&emsp;&emsp;&emsp;余りを最後に下から読むと変換された数になる<br>
  	１６）&emsp;３　　　９&nbsp;&thinsp;↑<br>
   	&emsp;&emsp;￣￣￣￣　　　&thinsp;｜<br>
    	&emsp;&emsp;&emsp;&emsp;０　　　３&thinsp;｜<br>
   	- 2進数 → 16進数への簡単な変換
   	  	- 2進数を4桁ごとに区切ってそれぞれの1桁の16進数に置き換える。そのまま並べればいい
   	  	- 16進数から2進数の変換では16進数の1桁を4桁の2進数に置き換える
   	  	- 8進数は3桁の2進数が対応するので同じことができる
   	  	- 区切りが悪いときは左に0を足す
     	- 基数変換
   		- 整数接尾語
       			- U・・・その整数定数は符号無し
       			- L・・・long型
       			- LL・・・long long型
       		- 変換指定子
           		- %o・・・符号無し整数型を8進数で表示
               		- %u・・・符号無し整数型を10進数で表示
               		- %x・・・符号無し整数型16進数小文字で表示
                   	- %X・・・符号無し整数型を16進数大文字で表示
                   	- long,long longを表示する場合は変換指定子の直前にlかllの長さ修飾子を置く
               		- %d・・・符号付き整数型を10進数で表示
                   	- %zu・・・size_t型の値をprintfする書式文字列
	- 浮動小数点定数<br>
  		3.14や2.0など。型を指定しなければdouble型になる。末尾にf、Fを置くとfloat型、l、Lを置くとlong double型になる
   		大きさとしては12桁まで表すことができ精度としては6桁が有効
   		左から7桁目を四捨五入した数字を1桁目の次に`.`を入れて、×10桁数-1乗する。これを×の前を仮数、何乗かを指数と呼ぶ
   		`1.23E4`とあると「1.23×10の4乗」となる
   		整数部や小数部を省略することも可能
   		`.5`で「double型の0.5」
   		`12.`で「double型の12.0」
   		`1L`で「long double型の1.0」となる
   	- マイナス表現
   	  	- 2の補数
   	  	  	- 2の補数の作り方
			- マイナス符号なしのビットを用意します
			- 全部反転します
			- 1足します
   		
   	- 文字定数<br>
    		- `'*'`のように`'`で囲んだ一文字だけの文字
   	  	- putchar関数を利用して表示する
   	  	- int型になる
   	  	- 日本語もint型になる
   	  	- `\n`は一文字として扱われるので表示可能
   	  	- %cは文字コードで当てはまる文字が出力される
		- char型で数字を扱うこともできて、%d、%o、%xでは10進、8進、16進の数字として表示される（数字文字ではない）
		- %cだと文字コードを参照して表示する。何進数の数字でも、変換されて同じ文字コードを参照する
		- 一文字のときだけ`''`
 		- 囲わないで数字として書けば多くてもいい
   	- オーバーフロー
   	  	- 符号付き整数型の演算の結果が表現可能な範囲を超えるなどすること
   	  	- 例外が発生する
   	  	  	- 処理系に依存するが、強制終了などする
   	  	- 符号無し整数型はオーバーフローしない
   	  	  	- 符号無し整数型の演算では演算結果が表現可能な範囲を超えた場合、その型で表現できる最大値に1を加えた値で割った剰余が演算結果となる（最小値から最大値までの値が順繰りに使われる）

- 識別子
  	- 変数、関数、構造体などの名前
  	- 先頭文字は必ず非数字（大文字および小文字のアルファベットと`_`(アンダーバー))のこと
  	- 大文字と小文字は区別される
  	- 2文字目以降は非数字または数字
  	- 識別子の文字として、非数字と数字以外に国際文字名も使える
  	- _で始まる識別子やアルファベット大文字1字だけの識別子は処理系が内部的に利用する可能性があるため識別子として利用してはいけない
  	- 有効範囲（スコープ）
  	  	- 変数や関数の識別子には通用する範囲が決められている
		- ファイル有効範囲
  			- 関数の外で宣言された識別子が宣言された場所からそのプログラムの終端まで名前が通用する
		- ブロック有効範囲
  			- ブロック内で宣言された変数の名前は、変数が宣言された場所からそのブロック終端の`}`まで通用する

- 区切り子
	- 識別子やキーワードなど、各語句のあいだには基本的に空白が必要
   	- ただし区切り子が置かれていればその前後の空白は不要
  		ex:「case2:」は不可だが「case(2):」は可能
	  
   	| 主要な区切り子 | | | | | | | | | |
  	|-|-|-|-|-|-|-|--|---|---|
  	| [] | () | {} | * | , | : | = | ; | ... | # |
   
