<details>
<summary>文</summary>
	
- 文は`;`で終わる

<details>	
<summary>選択文</summary>

- プログラムの流れを選択的に分岐させる
- if文とswitch文がある

<details>
<summary>if文</summary>
  
> if ( 式 ) 文
- 式を評価してその値が非0（ゼロでなければ）であれば文を実行する
- elseはなくてもよい<br>
  
- 制御式
	- if文の条件判定のために（）内に置かれた式
	- 後ろに`;`を置かないこと
- else
	- 制御式を評価した値が0だった場合elseの文を実行する
```c
if　(　式　)　文
文1（値  =  非0）;
else
文2（値  =  0）;
```
- else if文
	- if文には、if(式)文、if(式)文 else文の2種類しかないが、入れ子にすることで分岐を増やすことが可能
	- else if文は、厳密にはelseの後の文に新たにif文が追加されている形式になる<br><br>
> if文<br>
> else if文<br>
> else文

の形で、else ifは間に入れる
- 非ゼロの判定
```c
if (num)
　puts(”ゼロでない”);
else
　puts(”ゼロ”);
```
　制御式に定数を入れることもできるが、その場合絶対ゼロにはならない
- 0はTrueかFalseか
```c
　int a = 0;

	if (a = 0){
		puts("aは0です");
	} else {
		puts("aは0ではありません");
	}
```
1.&nbsp;&nbsp;aにゼロを代入する<br>
2.&nbsp;&nbsp;もし、<br>
3.&nbsp;&nbsp;式でaにゼロを代入する<br>
4-1.&nbsp;&nbsp;if文は値を評価して非ゼロだった場合最初の文、「aは0です」と表示する<br>
4-2.&nbsp;&nbsp;値を評価してゼロだった場合else文、「aは0ではありません」と表示する<br>
<br>
ifの式で0を代入しているので値はゼロになる。そのため必ずelse文の「aは0ではありません」と表示される<br>
<br>
```c
int a = 0;

	if (a == 0){
		puts("aは0です");
	} else {
		puts("aは0ではありません");
	}
```
1.&nbsp;&nbsp;aにゼロを代入する<br>
2.&nbsp;&nbsp;もし、<br>
3.&nbsp;&nbsp;式でaと0が等しいか評価している<br>
4-1.&nbsp;&nbsp;if文は値を評価して非ゼロだった場合最初の文、「aは0です」と表示する<br>
4-2.&nbsp;&nbsp;値を評価してゼロだった場合else文、「aは0ではありません」と表示する<br>
<br>
「もしaと0が等しければif文の最初の文を返すプログラムなので、aは0です」と表示される<br>

</details>

<details>
<summary>switch文</summary>

> switch ( 制御式 ) 文<br>

```c
switch ( 制御式 ) {
　case 0 :　・・・;　break;
　case 1 :　・・・;　break;
　case 2 :  ・・・;　break;
}
```
<br>

- 単一の式に基づいて、複数の分岐をする場合、簡潔に表現できる
- if文よりswitch文の方が読み間違えや書き間違いと誤解されることが減る
- 制御式を評価した値に基づいて結果に対応するラベルのプログラムに飛ぶ
- ()に囲まれた制御式は整数でなければいけない
 
- ラベル
	- `case 1 :`という形式で書かれる
	- ラベルの値は定数でなければいけない
	- 複数のラベルが同じ値を持つことはできない
	- 同じ処理をしたいcaseを上下に並べ、上のcaseを空白にして、break文もおかないことで、同じ処理をさせることができる
	- 「case」と「1」の間の空白は省略不可

<details>
<summary>break文</summary>

- ラベルの後の文が実行された後、`break;`とつけることで、switch文を中断させる
- break文がないと、次のcaseが続けて実行される
- 最後のcaseの末尾にもbreak文を置くことで、ラベルの増減に対応できる

</details>

- default
	- 制御式を評価した値がどのcaseにも一致しない際に飛ぶラベル

</details>

<details>
<summary>複合文（ブロック）</summary>

- `{}`を使う文
- {0個以上の文または宣言の並び}
- 文は何個でもよく、宣言も何個でもよい
- 文の一種で、構造上は単一の文とみなされる
- if文、elseは1つの文しか制御できない。
- 複数の文を制御するには複合文を使う

</details>

<details>
<summary>繰り返し文</summary>

<details>
<summary>do文</summary>

- 「制御式の評価で得られた値が値が真のあいだ、文を繰り返し実行せよ」という文
- doではじまり、文を挟んで、while(式);で終わる形式
- do「実行せよ」
- while「～のあいだ」
- 繰り返しの対象となる文のことを　ループ本体　という
- do文におけるループ本体は { から } までの複合文
- 継続条件はwhileの次の制御式が真であること
  
```c
do {
   文
} while ( 式 );
```

</details>

<details>
<summary>while文</summary>

- do文はループ本体の実行後に繰り返すか判定していたが、while文では実行前に行う
- do文は一度はループ本体が実行されるが、while文では、制御式の評価が偽であれば一度も実行されない
	```c
 	while ( 制御式 ) {
  	　　文
 	}
 	```
 
</details>

<details>
<summary>break文とcontinue文</summary>

- break文
	- switch文、do文、while文、for文といった選択文のループ本体の中でbreak文が実行されるとループを抜けて次に進む

- continue文
	- 選択文のループ本体の中でcontinue文が実行されると「ループ本体の残りの部分の実行」がスキップされて、ループ本体の終端に移動し、最初の制御式まで戻る
   	- for文ではcontinueしてスキップされても式3部分は実行される

- 無限ループ
  	選択文の制御式に必ず真とみなされる値(1など)を入れると無限ループする
</details>

<details>
<summary>for文</summary>
	```c
	for (式1; 式2; 式3) 文
	```
	- 式1は前処理にあたり、一回だけ評価、実行、変数の作成がなされる
	- 式2は繰り返すかを決める制御式。真であれば（）の後のループ本体の文が実行される
	- 式3は後始末処理あるいは次の繰り返しの準備。式3が実行されてから式2に戻る
	```c
	scanf("%d", &no); //noに入力された値を代入
	
	for (int i = 0; i <= no; i++) // 式1で変数iに0を初期化。式2でnoがi以上になるまで続けると設定。式3でi+1する
		printf("%d", i); // 式2の条件を満たす間行う
	putchar('\n'); // ループ終了すると改行
 	```
  	- 式1　前処理
   		- ここで宣言された変数はそのfor文の中だけで使える
     		- 別のfor文で同一名の変数を使うときは書くfor文ごとに宣言が必要
       		- 変数の宣言が必要のない場合（for文の前に宣言しているなど）、前処理が不要な場合は省略可能
	 - 式2　制御式
  		- この式を省略すると繰り返しの判定は真とみなされる
    		- そのためbreak文などを使わない限り無限ループになる
      	 - 式3　後始末/次の繰り返しの準備
		- 行うことがなければ省略可能
  		- すべての式を省略すると
    		``` c
      		for ( ; ; )
		文
  		```
    		となる
      	 - 式を省略する場合でもセミコロンは省略不可能
	 - 中断
  	 ```c
         int num;

	 printf("整数は何個：");
	 fflush(0);
	 scanf("%d", &num);
	 printf("終了は-9999\n");

	 int i; //iをfor文外でも使うので先に定義
	 int sum = 0; // 合計値
	 for (i = 0; i < num; i++){ //iは中断されても回数カウントに使えるよう0を代入
		int tmp;
		printf("No.%d：", i + 1); // iを何番目の入力なのかの表示にも使用するため+1する
		fflush(0);
		scanf("%d", &tmp);
		if (tmp == -9999) break; // 入力した値が-9999のとき中断する
		sum += tmp; // 合計値に足し合わせていく
	 }

	 printf("合計値：%d\n", sum);
	 printf("平均値：%.2f\n", (double)sum / i);
  	 ```
</details>

<details>
<summary>多重ループ</summary>

	- 繰り返し文のループ本体の中に繰り返し文が含まれていると多重ループが可能
 
</details>

</details>

</details>

</details>

<details>
<summary>式</summary>
  
- 変数や定数、それらを演算子で結合したものを式と呼ぶ<br>
```x + 32;```<br>
では`x`、`32`、`x + 32`のいずれも式とみなす<br>
代入演算子を用いた式は代入式という
- 式を評価する=答えが出る<br>
定数は評価されるとそのままの数が出てくる<br>
Trueは1、Falseは0と出る
  
</details>

<details>
<summary>書式</summary>
	
- printf関数に与える最初の実引数は書式文字列という
- %dは書式の指示で変換指定という
- \n = ¥n = 改行文字

<details>
<summary>変換指定</summary>
  
　％０９．９ｆ<br>
　　&nbsp;↓&nbsp;&nbsp;↓&nbsp;&nbsp;&nbsp;↓&nbsp;&nbsp;&nbsp;&nbsp;↓<br>
　　Ａ&nbsp;Ｂ&nbsp;C&nbsp;&nbsp;&nbsp;D<br>
  - A　フラグ
    - 0が指定されていると、数値の前に余白があるとき、０をつめて表示する
    - このフラグを省略すると空白がつめられる
    - -が指定されると左詰めになり、指定がないと右詰めになる
  - B　最小フィールド幅
    - 最低限の表示文字数の指定<br>
    この指定が省略されたり、指定された値を超える数値を表示するときは、その数値を表示するのに必要な桁数で表示される
  - C　精度
    - 表示する最小の桁数の指定<br>
    省略すると、整数の制度は１とされ、浮動小数点数の精度は6とされる
  - D　変換指定子
    - d・・・int型の整数を10進数で表示する指定
    - f・・・double型の浮動小数点数を10進数で表示する指定
    
</details>
</details>

<details>
<summary>変数</summary>

- 変数が有効になる範囲は決まっているので宣言する場所に気を付ける
  
- 変数の宣言<br>
> 型&nbsp;&nbsp;&nbsp;名前<br>
> int&nbsp;&nbsp;&nbsp;　n

intという型でnという名前の変数を宣言した<br>
- 変数は定義された型の性質に則って作られる
- 表現できる範囲も型に依存する
  
- 初期化
	- 実数に入れる値がわかっている際、最初から設定すること<br>
		```c
		int x = 57;
		```
		57のように宣言の際に設定する変数を初期化子という
  
<details>
<summary>不定値</summary>
    
- 変数の値を設定しないと、変数名を宣言したときに、とりあえず作られたその変数名のための場所に、昔そこにあったデータが残っていて、それが代入されてしまう<br>
```c
printf("nの値は%dです。\n", n);
```
→出力結果<br>
> nの値は7です。<br>

　不定値（ゴミの値）<br>
　初期化せず、宣言だけした変数に、まだ代入していない状態で別の変数にその変数を代入しようとするとwarningが出るので避ける
  
</details>

- カウンタ用変数
	- 繰り返し文の制御に使う変数
   	- 多くの場合iやjが使用される
  
</details>

<details>
<summary>型</summary>
  
- 暗黙の型変換
	- 異なる型の変数同士で計算すると、勝手に一方の変数の型が格上げされ、同じ型同士の計算になる 
	- より大きくて小数部を格納できる型に変換される

- キャスト<br>
> （型）式

の形式で、式の型を（）の型に変更する
  
<details>
<summary>int型</summary>
    
- 整数型      
- 小数点以下の数は扱えない
- int型で確実に表現できる値は-32767から32767まで<br>
```c
int x = 3.5;
```

　とすると、xに代入される値は3になる
```c
int x = 3.5; int y = x + 5.7;
```
　とすると、yに代入される値は8になる
         
</details>

<details>
<summary>double型</summary>
    
- 実数を浮動小数点数という形式で表す
- double型はそのひとつ
```c
double x = 3.141592;
printf("円周率は%fです。", x)
```
　→　出力結果
> 円周率は3.141592です。

- double型では小数点以下6桁まで表示される（5.2は5.200000となる）
    
</details>
  
</details>
  
<details>
<summary>関数</summary>
  
- 第一引数の1番目の変換指定(%dなど)に1番目の第二引数の整数を、第二引数の2番目の変換指定(%d)に2番目の第二変数の整数を自動的に代入する
  
- printf関数
	```c
	int no = 5;
	printf(”%dに10を足した値は%dです。”, no, no + 10);
	```
 
- puts関数
	- 実引数として与えられた文字の並びを出力した上で改行文字を出力する
	- puts(”・・・”)はprintf(”・・・\n”)とほぼ同じ働きをする
	- puts関数は書式設定や数値の出力は不可能
  
<details>
<summary>scanf関数</summary>
    
- キーボードからの読み込みを行う関数
- ひとつの関数で複数入力させる場合は、値と値の間で改行・タブ・スペースのいずれかを使用する
```c
scanf("%d", &no);
```
　第一引数で変換指定、第二引数で読み込む<br>
　noは変数名。変数名の前に&をつける
```c
scanf("%d%d", &n1, &n2);
```
　n1が一つ目の%dに、n2は二つ目の%dに読み込みされる
    
</details>
  
</details>

<details>
<summary>キーワード</summary>

- 特別な意味が与えられた37の語句
- これらは変数などには使用できない
	- auto
 	- break
    	- case
       	- char
       	- const
       	- continue
       	- default
       	- do
       	- double
       	- else
       	- enum
       	- extern
       	- float
       	- for
       	- goto
       	- if
       	- inline
       	- int
       	- long
       	- register
       	- restrict
       	- return
       	- short
       	- signed
       	- sizeof
       	- static
       	- struct
       	- switch
       	- typedef
       	- union
       	- unsigned
       	- void
       	- volatile
       	- while
       	- _Bool
       	- _Complex
       	- _Imaginary
  
</details>

<details>
<summary>演算子</summary>
	
- 単項算術演算子 
	- 単項+演算子
		- +a<br>
  			aの値
		- 負の値を入力しても負の値のまま表示する
		- +をつけずにそのままの変数を実引数としても動作は同じ
	- 単項-演算子
		- -a<br>
			aの符号を反転した値
		- 負の整数を入力すると反転されるので、正の値が出力される    
- !演算子
- ~演算子<br>
    
オペランドを１個のみ必要とするのが単項演算子<br>
２個必要とするものは２項演算子<br>
３個必要とするものは３項演算子<br>
- 演算の優先度<br>
	- 数学と一緒で、式の中に（）があれば優先される
	- 加減算より乗除算が優先される

- 前置増分演算子・前置減分演算子
	- これらの演算子が使用された式の評価で得られる値は、インクリメント・デクリメント**後**の値になる。インクリメント・デクリメントされた後に値が出力される
		- `--no`の no に「5」を代入すると得られる値は
			>  4
   			　となる

- 後置増分演算子・後置減分演算子
	- 後置増分演算子
		- `a++`の形でオペランドの値を一つだけ増やす
   		- 値を一つだけ増やすことを**インクリメントする**という
	- 後置減分演算子
		- `a--`の形で、オペランドの値を一つだけ減らす
		- 値を一つだけ減らすことは**デクリメントする**という
	- "後置"は演算子をオペランドの後ろに置くことによるネーミング
	- オペランドと演算子の間にスペースを入れないこと
   	- これらの演算子が使用された式の評価で得られる値は、インクリメント・デクリメント**前**の値になる。値を評価した後にインクリメント・デクリメントされる
		- `while (no >= ) printf("%d" , no--)`の no に「5」を代入して実行すると
			> 5 4 3 2 1 0
   			　となる
   		- ```c
   	 	  i = 1
   	   	  printf("%d", ++i)
   	   	  ```
   	   	  は、先にiの値に1プラスして、プラスした後の値（2）を表示する
   	   　　　-  ```c
   	 	  i = 1
   	   	  printf("%d", i++)
   	   	  ```
   	   	  は、プラスする前に評価（printf)されるので、先に1と表示されてからiの値に1プラスされ、表示はされないが値は2になる

- 代入演算子
	- 正式名称は単純代入演算子
	- =のこと

- 複合代入演算子
	- `a @= b`の形で、`a = a `bと基本同じ働きをする
   	- `a += 2`の場合、aの値に2を足した値に、aの値を更新する
   	- +=, -=, *=, /=, %=, <<=, >>=, &=, ^=, |= の10種類がある
   	- 演算を簡潔に表現できる
   	- 左辺の変数名を書くのが一回で済む
   	- 左辺の評価が一回限りである

- 等価演算子<br>
	どちらも等価演算子という
	- ==演算子<br>
		- `==` で左右のオペランドの値が等しいか判定する
		- 等しければ 1、そうでなければ 0 という値を生成する
		- `=`は代入になるので使用しないこと
	- !=演算子<br>
  		左右のオペランドが等しくないかどうか判定する
- 加減演算子
	- 加算 +
	- 減算 -
- 乗除演算子
	- 乗算 *
	- 除算 / (10÷2) = (10/2)
		| | 例 | x / y | x % y |
		----|----|----|----
   		| 正 ÷ 正 | x = 22, y = 5 | 4 | 2 |
   		| 負 ÷ 負 | x = -22, y = -5 | 4 | -2 |
   		| 正 ÷ 負 | x = 22, y = -5 | -4 | 2 |
   		| 負 ÷ 正 | x = -22, y = 5 | -4 | -2 |
	- 余り % （7÷3=2…1)（7 % 3 = 1)<br>
		文字列として`%`を表示するには`%%`と入力する<br>
		`整数 % 10` は最下位桁が出力される<br>

- 関係演算子<br>
	二つのオペランドの大小関係を判定する演算子

- <演算子<br>
	左が右よりも小さければ１，そうでなければ０（int型）
- \>演算子<br>
	左が右より大きければ１，そうでなければ０（int型）
- <=演算子<br>
	左が右以下であれば１，そうでなければ０（int型）
- \>=演算子<br>
	左が右以上であれば１，そうでなければ０（int型）
<br><br>
<=演算子と>=演算子は逆向きにできない
差を出すときは&&や||を使うこと<br>

```c
if (3 <= a <= 5)　//誤：3つのオペランドは扱えない
```

```c
if (a >= 3 && a <= 5)　//正
```

<details>
<summary>条件演算子</summary>

> 式1 ? 式2 : 式3

1.　式1を評価。式1が非0であれば式2を評価した値となる<br>
2.　0であれば式3を評価した値となる<br>
- 唯一の3項演算子

```c
int max = n1 > n2 ? n1 :n2;
printf("大きいほうの値は%dです。\n", max);
```
　二つのプログラムは同じ結果が出力される
</details>

<details>
<summary>論理演算子</summary>

- 三つの変数が等しいかどうかを求めるときは
  `if ( a == b && b == c )`とする<br>
　`if ( a == b && c )`だと<br>
　aとbが等しいとき、True(1)になるので、1とcがFalseになる

- 短絡評価<br>
　&&演算子は、aを評価した値が0であればbの評価を行わない<br>
　||演算子も、aを評価した値が非0であればbの評価を行わない<br>

<details>
<summary>論理 AND 演算子</summary>

- `a && b`<br>
　a かつ b<br>
 
　論理積
| a | b | a && b|
----|----|---|
| 非0 | 非0 | ***1*** |
| 非0 | 0 | 0 |
| 0 | 非0 | 0 |
| 0 | 0 | 0 |

　両方ともTrue（非0）であれば 1<br>
 <br>

</details>

<details>
<summary>論理 OR 演算子</summary>

- `||`のこと
- `a || b`<br>
　a または b (a と bも含む）<br>
 
 　論理和
  | a | b | A \|\| b |
  |----|----|----|
  | 非0 | 非0 | ***1*** |
  | 非0 | 0 | ***1*** |
  | 0 | 非0 | ***1*** |
  | 0 | 0 | 0|
  
　一方でもTrue（非0）であれば 1

</details>
</details>

- 論理否定演算子
	`! a`
	- オペランドが0と等しいかどうかを判定する演算子
	- ド・モルガンの法則
 		- 「各条件の否定をとって、論理積・論理和を入れ替えた式」の否定は、もとの条件と同じであるということ
		```c
  		a < 0 || a > 2
  		```
  		継続条件　aが不当な値であれば…
  		```c
    		!(a >= && a <= 2)
		```
    		終了条件の否定　aが妥当な値でなければ…
   		→　これは２つとも同じこと
   		- `x && y` = `!(!x || !y)`
		- `x || y` = `!(!x && !y)`
    		→　&&か||を反転
    		→　xとyを否定する形式に書き直す
    		→　全体に()をつけ、先頭に!をつける
    		↳　!をつける代わりに()の後に == 0 をつけ、Falese(0)にすることも可能
       
<details>
<summary>様々な演算子の評価</summary>

```c
int n = 51;

	printf("n > 0 : %d\n", n > 0);
	// n > 0 : 1
	// 「n > 0 : (10進数で)(第1オペランドの方が第2オペランドより大きい場合は"1"、そうでなければ"０"を表示する)」

	printf("n == 0 : %d\n", n == 0);
	// n == 0 : 0
	// 「n == 0 : (10進数で)(第1オペランドと第2オペランドが等しければ"1"を、そうでなければ"0"を表示する)」

	printf("n / 2 = %d\n", n / 2);
	// n / 2 = 25

	printf("n / 2.0 = %.1f\n", n / 2.0);
	// n / 2.0 = 25.5

	printf("n %% 2 = %d\n", n % 2);
	// n % 2 = 1

	printf("n - 2 = %d\n", n - 2);
	// n - 2 = 49

	printf("(int)5.7 : %d\n", (int)5.7);
	// (int)5.7 : 5

	printf("(double)5 : %.1f\n", (double)5);
	// (double)5 : 5.0
```
</details>
  
<details>
  <summary>オペランド</summary>
    
- 演算の対象となる変数や定数
- x + y のとき、xとyはオペランド、+は演算子という
- 左側のオペランドは第１オペランド/左オペランドという
- 右側のオペランドは第２オペランド/右オペランドという

</details>

</details>

- 式文
	- 式の末尾に`;`がついて文という形になる
	- 式の後ろに`;`を置いた文は式文という
   	- for文やif文の制御式の後ろに；を置いてしまうと、；だけが文と認識されてプログラムがうまく動かなくなることがある
   	- ；だけの文が空文という式文になる

- プログラム
  
　人が読めるもの　コンピュータが理解できるもの<br>
　ソースプログラム　→　実行プログラム<br>
　　　　　　　 コンパイル

- コメント
	- 伝統的コメント
 		- ```/*・・・*/```
		- 行の先頭や末尾でなくてもよい
		- 複数行にまたがることができる
		- `*/`で閉め忘れると大変なことになる
  
	- 行末コメント    
		- ```//・・・```
		- //から行末までがコメント
		- 開始は行の先頭でなくてもよい
  
	- 入れ子
		- 可能な入れ子    
			 ```/*・・・//・・・*/```
			 ```//・・・/*・・・*/```
		- 不可能な入れ子<br>
			 ```/*・・・/*・・・*/・・・*/```
      
- 引数
    
>仮引数　実引数<br>
printf("こんにちは");<br>
関数

- 処理系
	- コンパイル方式
		- ソースコードをコンピューターが直接理解・実行できる形式に翻訳する方式
  
	- インタプリタ方式
 		- ソースコードをコンピューターがプログラムを一行ずつ解釈しながら実行する方式
- 定数
	- 変数だけでなく、プログラムに埋め込まれた定数にも型がある
	- 整数定数<br>
  		5や37など。基本的にint型
	- 浮動小数点定数<br>
  		3.14や2.0など。基本的にdouble型
   	- 文字定数<br>
    		'*'のように'で囲んだ一文字だけの文字
   	  	putchar関数を利用して表示する
   	  	int型になる
   	  	日本語もint型になる
   	  	\nは一文字として扱われるので表示可能

- 識別子
  	- 変数、関数、構造体などの名前
  	- 先頭文字は必ず非数字（大文字および小文字のアルファベットと_(アンダーバー)のこと
  	- 大文字と小文字は区別される
  	- 2文字目以降は非数字または数字
  	- 識別子の文字として、非数字と数字以外に国際文字名も使える
  	- _で始まる識別子やアルファベット大文字1字だけの識別子は処理系が内部的に利用する可能性があるため識別子として利用してはいけない

- 区切り子
	- 識別子やキーワードなど、各語句のあいだには基本的に空白が必要
   	- ただし区切り子が置かれていればその前後の空白は不要
  		ex:「case2:」は不可だが「case(2):」は可能
	  
   	| 主要な区切り子 | | | | | | | | | |
  	|-|-|-|-|-|-|-|--|---|---|
  	| [] | () | {} | * | , | : | = | ; | ... | # |
   

    
</details>
  
</details>


