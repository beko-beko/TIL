
- 処理方式
  - コンパイラとインタプリタを併用している
  - Java専用コードにコンパイルするので、JVMさえあればどのPCでも使える
  - 頻繁に使われるコードはJVMにコンパイラが入っていてそっちで処理するので高速
  - JVMがサンドボックスになるので安全性が高い
  - 状況に応じて最適化できるのでコンパイル方式よりパフォーマンス調整できる

- ブロック
  - `{}`で囲まれた部分をひとまとまりとして扱う
  - 通常`{}`で囲まれた部分を指すが、1文のみの場合は`{}`を省略できる
  - 外側の`{}`で囲まれたブロックをクラスブロック、内側のブロックはメソッドブロックという
    - 必ずこの二重構造を持つ
    - クラスブロックのクラス名はソースプログラム名と合わせる

- スコープ
  - 変数が利用可能な場所の範囲
  - ブロック内で宣言した変数はブロックが終わると消滅する。ブロックの外側では利用できない

  - mainメソッドはC言語でいうメイン関数
    - プログラムはここからはじまるのでエントリーポイントという
    - ```Java
      public static void main(String[] args) {
      ;
      }
      ```

- 式
  - 演算子ではないものがオペランド（式）
  - リテラル
    - 数値や`true`,`false`,`'`や`"`で囲まれた文字や文字列
    - リテラル中の任意の場所に`_(アンダースコア)`を含めることができる
    - `0b`と書くと2進数
    - 符号無しは存在しない

    - エスケープシーケンス
      - `\(エン)`とそれに続く1文字からなる表記
      - `\n`　改行文字
      - `\"`　二重引用符
      - `\'` 引用符
      - `\\`　円記号
      - `\u + 16進数4桁の数字`　unicodeで文字を記述可能
      - 警告を出す制御文字はない。環境に依存するのでJavaの設計思想に反するため

    - 接尾辞（サフィックス）
      - 型サフィックス
        - long：`l`,`L`
        - float：`f`,`F`
        - double：`d`,`D`
 
    - 数値プレフィックス
      - 何進数の数かを表す
      - `0b`,`0x`など
       
    - 区切り文字
      - 数値セパレーター（桁区切り）
        - 桁数の大きな値の可読性UP
        - ex: `12_34_56`
        - ex: `12__34`
        - 挿入できるのは数値の間だけ
        - 数値の先頭や末尾、小数点の隣、型サフィックスの隣、数値プレフィックスの隣に書いてはいけない

    - 式の評価
      - 演算子による評価結果に値が置き換わる
      - 演算子には優先順位がある
      - 同じ優先順位の演算子が複数ある場合、結合方向に従って方向の順に評価される

- 文
  - 末尾には必ず`;`をつける

- コメント
  - `/*    */`
    - 文中に入れられる
  - `//       `
    - 文末`//`の後がすべてコメント
   

<details>
<summary>演算子</summary>
  
- 算術演算子
   - 左右の数値オペランドを使って四則計算を行う演算子
     
| 演算子 | 機能 | 優先順位 | 評価の方向 | 評価の例 |
| ---- | ---- | ---- | ---- | ---- |
| + | 加算 | 5 | 左 → 右 | 3 + 5 →8 |
| - | 減算 | 5 | 左 → 右 | 10 - 3 → 7 |
| * | 乗算 | 4 | 左 → 右 | 3 * 2 → 6 |
| / | 除算 | 4 | 左 → 右 | 3.2 / 2 → 1.6  9 / 2 → 4 |
| % | 剰余 | 4 | 左 → 右 | 9 % 2 → 1 |

- 文字列結合演算子
    | コード | 結果 | 起きていること |
    |----|----|----|
    | "文字列" + 10 | 文字列10 | 10が文字列の末尾に連結され、10までの文字列になる |
    | 10 + 10 + "文字列" | 20文字列 | 先に10 + 10が計算され、文字列が連結される |
    | "文字列" + 10 + 'a' | 文字列10a | 文字列に10とaが順に連結されて全体が文字列になる |
    | "文字列" + 10 + 10 | 文字列1010 | 文字列に10と10が順に連結され全体が文字列になる |
    | "文字列" + (10 + 10) | 文字列20 | ()がついているので先に10 + 10が計算され、20が文字列に連結され全体が文字列になる |
    | 'a' + 10 + 10 | 117 | aの文字コードの数字が97で、一文字はint型の文字コードとなるので、97 + 10 + 10されてintの117が出力される |

- 代入演算子
   - `=`演算子
     - 右辺を左辺に代入
     - 優先順位 15
     - 左 ← 右 結合
     - `a = 10` → `a`(中身は10）

- 複合代入演算子
    | 演算子 | 機能 | 優先順位 | 結合 |
    |----|----|----|----|
    | += | 左辺と右辺を加算して左辺に代入 | 15 | 左 ← 右 |
    | -= | 左辺と右辺を減算して左辺に代入 | 15 | 左 ← 右 |
    | *= | 左辺と右辺を乗算して左辺に代入 | 15| 左 ← 右 |
    | /= | 左辺と右辺を除算して左辺に代入 | 15 | 左 ← 右 |
    | %= | 左辺と右辺を除算し、その余りを左辺に代入 | 15 | 左 ← 右 |
    | += | 左辺の後に右辺を連結して代入 | 15 | 左 ← 右 |

- インクリメント/デクリメント演算子
    | 演算子 | 機能 | 優先順位 | 結合 |
    |----|----|----|----|
    | ++ | 値を1増やす | 1 | 左 → 右 |
    | -- | 値を1減らす | 1 | 左 → 右 |
    
- 文字列結合演算子

- 関係演算子
  - `==`
    - 左辺と右辺が等しい
  - `!=`
    - 左辺と右辺が異なる
  - `>`
    - 左辺が右辺より大きい
  - `<`
    - 左辺が右辺より小さい
  - `>=`
    - 左辺が右辺より大きいか等しい
  - `<=`
    - 左辺が右辺より小さいか等しい

- 論理演算子
  - `&&`
    - 左辺と右辺両方の評価が`true`なら、`true`
  - `||`
    - 左辺か右辺どちらか一方でも`true`なら、`true`
  - `!` (否定演算子)
    - `!`に続く条件式に合っていなければ`true`

 - 短絡評価（ショートサーキット）
   - `&&`は左辺が`false`なら右辺の評価は行わない
   - `||`は左辺が`true`なら右辺の評価は行わない

 - 両辺を必ず評価する論理演算子
   - `&`, `|`
     `&`と`|`がそれぞれひとつずつであれば、短絡評価を行わず、両辺を評価する

</details>

<details>
<summary>変数</summary>
	
- 変数宣言
  - `型名 変数名;`
  - ex: `int a;`
  - 宣言時に代入して初期化が可能
    - `型名 変数名 = 値;`
  
- 変数名
  - 変数など自分で名前をつけるものに使える文字を識別子という
  - 1文字目
    - 小文字と大文字の英字、`_(アンダーバー)`、`$(ドル)`
  - 2文字目
    - 1文字目のものに加え、数字
  - 予約語は不可
  - Java8までは`_(アンダーバー)`のみの変数名が利用可能だったが現在は不可
  - 慣習的には、変数名の1文字目は小文字にする。ただし、複数の単語をつなげて変数名にする場合は2つ目以降の単語の先頭を大文字にする

  - 変数を初期化せずコンパイルするとエラーになる

</details>

<details>
<summary>型</summary>
	
- 基本型(プリミティブ型)
  - 整数型
    - 整数型
      - int
        - 整数のデフォルトはint
        - 4バイト
  
      - short
        - 1バイト
        
      - long
        - 8バイト
        
      - byte
        - 1バイト
        
    - 小数型
      - double
        - 実数のデフォルトはdouble
          - 8バイト
          
      - float
        - 4バイト
        
    - 文字
      - char
      - `''`(シングルクォーテーション)で囲む
        - 1文字**2バイト**
        
    - 真偽値
      - boolean
        - `true`か`false`を返す
        - 処理系によるが1バイトが多い
        
- 参照型
  - null
    - 参照型変数に代入可能
    - どこも参照していない状態にする
    - `null`を代入してどこも参照していない状態にすることを「参照を切る」という
      
  - 文字列型
      - Strinig
        - `""`で囲む
        - テキストブロック
          - 改行の多い文字列で直感的に記述する方法
          - 2つの`"""`で囲まれた文字列を表記したままの文字列情報として解釈される
          - 開始の`"""`の後ろには文字列情報を書いてはならず、すぐに改行しなければならない
          - 2つの`"""`の空いたの各行のうち、最も左側に文字を記述した部分を複数行リテラルの左端と見なす
          - 2つの`"""`内の各行の左端までの空間と、後ろの`"""`の前の空間はスペースかタブかどちらかに統一すると実行結果が揃う

- 型変換
  - 小さい型から大きい型に変換する際は明示しなくても自動でやってくれる
  - 大きい型から小さい型に変換する際は明示しないとエラーになる
  - ex: ```Java
           double a = 5.3;
           int b = a; // 「bの値は"5"にならない。エラーになる」
        ```
    - byte型とshort型の変数にint型を代入することは、実害のない範囲で例外的に認められている
       
  - キャスト演算子
    - 変数の前に(型名)を記述すると、`()`内の型に変換する
    - ex: :`int a = (int)3.2;`

  - 演算時の自動型変換
    - 異なる型で演算を行うと、意味的に大きな型に統一されてから演算される
    - byte < short < int < long < float < double

  - byteとshortの演算時強制型変換
    - 演算時も強制的にint型に変換される
    - byte型のb1とb2を足す場合`byte a = b1 + b2`ではなく`int a = b1 + b2`とする

  - 文字列を含む演算時の型変換
    - 片方のオペランドがString型なら、もう一方もString型に変換してから連結する
</details>

<details>
<summary>命令</summary>

- 命令実行の文
  - `呼び出す命令の名前(引数);
- System.out.
  標準出力という意味
- println
  画面に出力して改行
- print
  画面に出力（改行はしない）

- キーボードからの入力を受け取る
  - `String str = new java.util.Scanner(System.in).nextLine();
    - nextLine()は文字列
  - int n = new java.util.Scanner(System.in).nextInt();
    - nextInt()は整数
  - Scanner
    - やや遅い
    - 自動変換(nextInt()など)
    - 簡単な標準入力に
  - BufferedReader
    - 高速
    - 自動変換できない
    - Integer.parseInt()で自分で変換が必要
    - 大量のデータやファイル処理に向いている

- equals
  - 文字列を比較するにはこの関数がいる
  - `文字列型の変数.equals(比較相手の文字列)`

- Math.max(a, b)
  - 引数2つを比較して大きい方を数値が返却される
- 文字列を数値に変換する
  - Integer.parseInt(str)
    - 整数に変換
  - Double.prseDouble(str)
    - 小数に変換
  - ```Java
       String c = "30";
		   System.out.println(Intrger.parseInt(c));
    ```
    - 上記コードも実現可能だが、Double型のcを再利用できないので、再利用したい場合は別で変数をとる
      - ```Java
           String c = "30";
           int n = Interger.parseInt(age);
           System.out.println(n);
        ```

  - Random()
    - Randomメソッドを呼び出す
      - int r = new java.util.Random().nextInt(90);
        - 以下の書き方と同じ
          - Random random = new Random();
          - int r = random.nextInt(90)
        - MathクラスのRandomメソッドでも可能
          - int r = (int)(Math.random()*90);
          - double型しか返らない
    - `nextInt(90)`の場合、0～89が返る。
      1から90にしたい場合は`nextInt(90) + 1`にする

</details>

<details>
<summary>制御構文</summary>

- 条件式
  - 条件式は、評価結果がtrueまたはfalseになるものでなければならない
  - 文字列の比較は`文字列型の変数.equals(比較相手の文字列)`で行う
  - 条件式内に`=`を使用するのは推奨されない

  - 論理演算子を用いた条件式
    - 2つ以上の条件を組み合わせられる
    - ex : `if (a > b && c == 5) {…`

- if文
  - ```Java
       boolean a = true;
       if (a == true) {
         /* 中略 */ ;
      　} else {
         /* 中略 */ ;
        }
    ```
  - if構文の種類
    - if-else構文
      - 通常の、ifの条件式に当てはまればifの中の文を、当てはまらなければelseの中の文を実行する
    - if構文
      - ifの条件式に当てはまらなければ何もしない場合、elseを省略できる
    - if-else if-else構文
      - falseのとき更に別の条件で分岐させる

- switch文
  - 条件式には整数（byte, short, int）、String, char型が使用可能
  - `switch`の直後の条件式は変数名を書く
  - `case`の直後には値を書き、その直後には`-> {処理内容}`を記述する
  - `default -> {処理内容}`の部分は条件に合致しないときの処理が不要な場合は省略可能
  - 値は複数設定でき、その値のcaseにbreakがなくても下のcaseに続くことはない
  - ex : ```Java
            int a = 1;
            switch (a) {
              case 1, 2 -> {
                System.out.println("x");
              }
              case 3 -> {
                System.out.println("y");
              }
              case 4, 5 -> {
                System.out.println("z");
              }
            }
         ```
  - 伝統的なswitch文
    - `case`の次の値の後に`:`をつける
    - `-> {}`は使わない
    - case内の文の最後に`break;`を置くとそのcase内の文の処理が終わるとswitch文を抜け出す
    - `break;`を置かなかった場合、下のcaseも続けて実行される
      - 複数の値を1つのcaseに設定するときは<br>
        `case 1, 2:`もしくは<br>
        ```Java
           case 1:
           case 2:
        ```<br>
        と記述する
        
      - ex : ```Java
                int a = 1;
                switch (a) {
                  case 1, 2:
                    System.out.println("x");
                    break;
                  case 3:
                    System.out.println("y");
                    break;
                  case 4, 5:
                    System.out.println("z");
                } 
             ```
  - switch式
    - 変数にswitch文全体を代入することで、変数を引用したとき、switch文の結果が変数に代入される
    - defaultは省略可能だが、変数に代入する際は必須
    - 伝統的なswitch文は使えない
    - ```Java
         String s = switch (a) {
           case 1 -> "w";
           case 2 -> "x";
           case 3 -> "y";
           default -> "z";
         };
         System.out.println("a");
      ```
      
- while文
  - `while ()`の()内の条件式がtrueの間、直後の{}で囲まれたブロック部分を繰り返し実行する
  - ```Java
       boolean a = true;
    while (a == true) {
      /* 中略 */ ;
    }
    ```

- do-while文
  - 最初に一度は必ず実行する
  - ex : ```Java
            do {
              a--;
            } while (a < 5);
         ```

- for文
  - 決まった回数だけ繰り返す
  - 必ずしも繰り返し条件や繰り返し時処理に利用した変数を、繰り返し条件でも使わなければならないわけではない
  - 繰り返し条件式内の各文は省略可能
      - ex: `for (;;)`
  - ex : ```Java
            for (int i = 0; i < 10; i++) {
              System.out.println("ABC");
            }
         ```

- 制御構造のネスト（入れ子）
  - ```Java
       for (int i = 1; i < 10; i++) {
			   for (int j = 1;  j < 10; j++) {
    ```

- 繰り返しの中断
  - break文
  - continue文
    
</details>

<details>
<summary>配列</summary>

- 配列の宣言
  - `型名[] 変数名`

- 要素の作成と代入
  - `配列変数名 = new 型名[要素数];`
  - ex: `a = new int[5];`

- 配列の宣言と要素の作成を同時に行う
  - `型名[] 配列変数名 = new 型名[要素数];`
  - ex: `int[] a = new int[5];

- 配列の作成と初期化
  - `型名[] 配列変数名 = new 型名[] {値1, 値2...};`または
  - ex: `int[] a = new int[] {10, 20...};`
  - `型名[] 配列変数名 = {値1, 値2...};`でも可
  - ex: `int[] a = {10, 20...};`

- 配列のメモリ
  - 配列変数と要素はメモリ上の別の場所に格納される。配列変数には先頭要素のアドレスが代入される

- 参照
  - 配列変数名を記述すると「この配列の実体のアドレスは○○です」と返す
  - メモリ上のアドレスを代入する変数を参照型という
  - array[n]としたとき、配列arrayからarray[0]のアドレスを見つけ、そこからn個後ろの区画を読み書きする

- 配列の代入
  - 別の配列に配列を代入すると同じ配列を参照するので、片方を変更するともう片方も変わる

- 配列を別の配列にコピーする
  - Arrays.copyOf()
    `型名[] コピー先配列名 = Arrays.copyOf(コピー元配列名, コピーしたい要素数);`
    `int[] copied = Arrays.copyOf(original, original.length);`
    - 要素数を増やすことも可能。その場合、追加分の要素番号の値はデフォルト値になる
  - System.arraycopy()
    - 同じサイズでしかコピーできない
    - コピー範囲を細かく指定可能
    - `System.arraycopy(コピー元配列名, コピー元のコピー開始位置要素番号, コピー先配列名, コピー先のコピー開始位置要素番号, 長さ)`
        ```Java
           int[] original = {10, 20, 30, 40, 50};
           int[] copied = new int[3];
           System.arraycopy(original, 1, copied, 0, 3);
           // コピー先配列出力 20, 30, 40
        ```
    - Arrays.copyOf()より高速

- ガベージコレクション
  - 自動的にどの変数からも参照されなくなったメモリを片付けてくれる仕組み
  - 対象はヒープ領域（動的なメモリ管理を行う場所）
    
- 配列の長さを調べる
  - `配列変数名. length`
    
- 拡張for文
  - 配列の要素を順番に参照する
  - ```Java
       for (型名 任意の変数名 : 配列変数名) {
         ;
       }
    ```
  - ex: ```Java
           for (int value : scores) {
             ;
    	   }
    	```

- 多次元配列
  - 2次元配列の宣言
    - `型名[][]配列変数名 = new 型名[外側の配列の要素数][内側の配列の要素数];`
    - 外側の配列の要素数は省略可能
    - `型名[][] 配列変数名 ={{値1, 値2, 値3}, {値4, 値5, 値6}};`でも可

  - 2次元配列の要素の利用
    - `配列変数名[外側の配列の要素番号][内側の配列の要素番号]`
    
    
 
</details>

<details>
<summary>メソッド</summary>

- 各メソッドの順序は自由。必ずmainメソッドから開始し、mainメソッドの上に他のメソッドが書かれていても、下に書かれていてもどちらでもmainメソッド内で呼び出されていれば問題ない

- メソッドの定義
  - ```Java
       public static void メソッド名() {
         ;
       }
    ```

- メソッドの呼び出し
  - `メソッド名()`

- return文
  - メソッド内でreturn文を記述するとそこでメソッドは終了するので、その後ろの処理は行われない
    
  - メソッドの戻り値
  - 戻り値は一つのみ
    - 引数なしで戻り値のあるメソッド
      - ```Java
           double getAvg() {
           double avg = score /20;
           return avg;

           main() {
           double num = h1.getAvg();
           ```
- オーバーロード（多重定義）
  - 同じ名前のメソッドを定義すること
  - 引数の型が異なるか、引数の数が異なる場合、同じ名前のメソッドを作れる
  - 引数は同じで、戻り値の型だけ異なるものは定義できない
  - シグネチャ
    - メソッド宣言に記述するメソッド名、引数の個数、型、並び順の情報（戻り値の型は含まない）

</details>

- 文字列の初期化
  - null

- 文字列の要素数の取得
  - `文字列変数名.length()`
  

</details>

- ArrayIndexOutOfBoundsException
  - 配列の要素が範囲外の例外

- NullPointerException
  - nullが格納されている配列変数を利用しようとすると発生する


- final
  - 続く変数などを上書き不可にする
  - finalをつけた変数を定数という
  - 定数なので大文字ですべて記述する
  - `final 型名 定数名 = 初期値`
  - 必ず初期化する
    
