<details>
<summary>メソッド</summary>

<details>
<summary>オーバーロード（多重定義）</summary>

- 同じ名前のメソッドを定義すること
- 引数の型か数を変えること
  
</details>

<details>
<summary>コンストラクタ</summary>

- インスタンス生成時に自動的に実行される
- クラスはインスタンス化の際、必ずコンストラクタを実行する
- すべてのコンストラクタは、親クラスのコンストラクタを呼び出す
- コードに記載がないとき、自動的に引数なしの親クラスのコンストラクタを呼び出す
- クラスと同名にすること
- 戻り値なし

<details>
<summary>引数を渡すとき</summary>

- `クラス名 インスタンス名 = new クラス名(実引数1, 実引数2...);`
  
</details>

<details>
<summary>デフォルトコンストラクタ</summary>

- コンストラクタが1つもないとき自動的にコンパイル時に追加される
- 引数、処理内容なし

</details>

<details>
<summary>他のコンストラクタの呼び出し</summary>

- `this(引数);`
- コンストラクタの先頭に記述する
  
</details>

<details>
<summary>親クラスのコンストラクタの呼び出し</summary>

- `super(引数);`
- コンストラクタの先頭に記述する
  
</details>

<details>
<summary>他のコンストラクタと親クラスのコンストラクタを両方呼び出したい</summary>

- 一緒には書けないので`this()`を先に呼出し、呼び出した先のコンストラクタで`super()`を記述する

</details>
</details>

</details>

<details>
<summary>クラス</summary>

<details>
<summary>フィールド</summary>

- クラスブロック内に宣言された変数
- 整数変数は0で初期化される
- 文字列はnullで初期化される

<details>
<summary>定数フィールド</summary>

- フィールド宣言の先頭に`final`をつけると書き換えられなくなる

</details>
</details>
<details>
<summary>インスタンス</summary>

- Hero h2としてh2 = h1としても、h1を別のところから参照できる変数が増えただけで、Heroクラスのインスタンス自体はh1の一個のみである
- 同じパッケージの、別のソースファイルのクラスはクラス名のみで呼び出せる

- 宣言
  - `クラス型名 変数名;`
  - ex: Hero h1;
- インスタンスを生成して代入
  - `変数名 = new クラス型名();`
  - ex: `h1 = new Hero();`

</details>


<details>
<summary>初期化ブロック（初期化子）</summary>

- コンストラクタより先に実行される名前のないブロック
- 複数のコンストラクタに共通する処理を実行
- 1つのクラスに複数列記可能。上から順に処理される

<details>
<summary>インスタンス初期化子</summary>

- インスタンスが生成される度にこのブロック内の処理が実行される
- `{ 処理内容 }`
  
</details>
<details>
<summary>クラス初期化子（静的初期化ブロック）</summary>

- クラスがはじめてロードされたときに1回だけ実行される
- `static { 処理内容 }`

</details>
<details>
<summary>初期化ブロックの実行</summary>

1.superクラスのコンストラクタ呼び出し
2.初期化ブロック
3.自分のクラスのコンストラクタ
  
</details>
</details>
</details>
<details>
<summary>インターフェース</summary>

- 抽象度の高い抽象クラスを特別扱いする
- `public interface インターフェース名 { ... }`
  
<details>
<summary>インターフェースの条件</summary>

- 基本的に、すべてのメソッドが抽象メソッドである
  - インターフェース内で宣言されたメソッドは、自動的に public かつ abstract になるので省略可能
  - インターフェース内で処理内容を持てるメソッド
    - defaultメソッド
      - `default 戻り値の型 メソッド名(引数リスト) { 処理のデフォルト実装 }`
      - 継承先でオーバーライドされなかった場合、自動的にデフォルト実装として定めた処理内容でオーバーライドされたものとみなされる
- 基本的に、フィールドを1つも持たない
  - 定数(publicstatic finalがついたフィールド)だけは宣言可能
    - その場合、public static finalは省略可能
      - ➡ インターフェース内でフィールドを宣言すると、自動的にpublic static finalが補われ、定数を宣言したことになる
`public`以外の修飾子は使用不可

</details>
<details>
<summary>インターフェースを継承して子クラスを定義する</summary>

- implements
  - `public class クラス名 implements インターフェース名 { ... }`

</details>
<details>
<summary>多重継承</summary>

- 通常、親クラスを複数持つことはできないが、インターフェースであれば、特別に多重継承が可能
- 親クラスが2つあると、同じ名前のメソッドを複数継承してしまう可能性がある。しかしインターフェースであれば必ずインターフェースを継承したクラスはそのメソッドをオーバーライドするので、そのような事故を防げる
- 多重継承の構文
  - `public class クラス名 implements 親インターフェース名1, 親インターフェース名2,... { ... }`
  
</details>
<details>
<summary>インターフェースからインターフェースへの継承</summary>

- `public interface インターフェース名 extends 親インターフェース名 { ... }`
- インターフェースの多重継承
  - `public interface インターフェース名 extends 親インターフェース名1, 親インターフェース名2... { ... }`
- 親クラスからの継承とインターフェースの実装を同時に行う
  - `public class クラス名 extends 親クラス implements 親インターフェース名1, 親インターフェース名2, ... { ... }`
  
</details>
</details>
<details>
<summary>継承</summary>

- 既存のクラスを元に、メソッドや変数を追加したクラスを作ること
- コンストラクタは継承しない
- 親クラスから見て、子クラスを複数定義することも可能
- 孫クラスや曾孫クラスも定義することも可能
- 多重継承は不可
  - 子クラスから見て、親クラスはひとつだけしか持てない

- 子クラスの定義
  -  `public class サブクラス名 extends スーパークラス名 { スーパークラスとの差分となるメンバ }`

- オーバーライド
  - 子クラスで親クラスのメソッドを再定義すること
  - 条件
    - 戻り値の型、メソッド名、引数の型と形がすべて同じであること
    - 子クラス内で定義し直せば上書きされる

- super
  - 今よりひとつ内側のインスタンス部分を指す予約語
  - 親インスタンス部分のフィールドを利用
    - `super.フィールド名`
  - 親インスタンス部分のメソッドを呼び出す
    - `super.メソッド名(引数)`
    - ex:

```java
   class PoisonMatango extends Matango {
   ...
   public void attack(Hero h) { // 親クラスのMatangoクラスにもあるメソッド
       super.attack(h); // 親クラスの内容を引き継ぐ
       ... // 子クラスでの追加部分
```

   - 祖父母インスタンス部分へのアクセス方法はない

- 抽象メソッド
  - 何もしないメソッド
  - 現時点では何をするかを確定できいないメソッド
  - 実装内容を持たないメソッド
  - `public abstract 戻り値の型 メソッド名(引数リスト);`
  - メソッドだが`{}`ではなく`;`をつける
  - 実装
    - 未定だったメソッドの内容が確定すること

</details>


<details>
<summary>パッケージ</summary>

- クラスを分類する仕組み
- クラスをパッケージに所属させる
  - `package 所属させたいパッケージ名;`
  - ソースコードの先頭に記述すること
 
- 完全限定クラス名
  - パッケージに入れたクラスは、パッケージ名も書かないと指定できなくなる
  - パッケージ名を先頭につけた完全なクラス名のことを完全限定クラス名、完全修飾クラス名、略してFQCNという
  - `パッケージ名.クラス名`
  - 同じパッケージ内で他のクラスを呼び出す際は、クラス名のみでいいが、完全限定クラス名を使用してもエラーにはならない
    
  
</details>

<details>
<summary>インポート</summary>

- 一度クラスやパッケージをインポートすればそのコード内で長い入力をせずに済む
- パッケージ内のすべてのクラスをインポートする
  - `import パッケージ名.*;`
- 1つのクラスのみをインポートする
  - `import パッケージ名.クラス名;`
    
</details>
<details>
<summary>多態性（ポリモーフィズム）</summary>

- インスタンスの多態性
  - インスタンスの左辺と右辺を別の型で指定できる
  - この場合、中身は本当はSuperHeroだが、Characterとして捉える
    - ex: `Character c = new SperHero();`
  - 親クラス = 子クラスは可能
  - 親族じゃないクラス、子クラス = 親クラスは不可
  - 抽象クラスやインターフェースはインスタンス化できないが、箱の型（左辺）にならできる
  - 中身のクラスのメソッドも、箱の型が使えないメソッドだと使えない
    - コンピューターは中身の型の名前を忘れ、箱の型としてしか捉えられなくなる
  - ただし、箱と中身両方に存在するメソッドを実行する場合、中身のメソッドが実行される
  - 別のクラスのインスタンスを配列にまとめられる
    - インスタンス化する宣言の左辺を統一すれば同じ配列に入れられる
      - ex:
        
```java
   Character[] c = new Character[3];
   c[0] = new Hero();
   c[1] = new Thief();
   c[2] = new Wizard();
```

</details>
<details>
<summary>カプセル化</summary>

- フィールドのアクセス制御
  - `アクセス修飾子 フィールド宣言;`
- メソッドのアクセス制御
  - `アクセス修飾子 メソッド宣言 { ... }`

- クラス宣言の前に`public`をつけないと、そのクラスへのアクセスは同一パッケージに属するクラスのみ許可される
  - 中のメソッドが`public`でもクラス自体が`public`でなければアクセス不可

 - `package private`クラスの特徴
    - クラス名はソースファイル名と異なってもよい
    - 1つのソースファイルに複数のクラスを宣言してもよい
    - 1つのファイルに1つの`public class`
    - `package private`クラスであればいくつあってもよい
    - 1つの`public`クラスと複数の`package private`クラスでもよい

- フィールドを`private`にすると、外からアクセスできなくなるのでは？
  ➡ そのクラスのメソッドを経由して操作可能
     ex: クラス a ➡✖ クラス b の private フィールド ba
         クラス a ➡〇 クラス b の bb メソッド ➡〇 クラス b の フィールド ba
  - メソッド経由じゃないとフィールドが触れないなら、他クラスのフィールドを参照できないのでは？
    - フィールド値を取り出す/代入するだけのメソッド
      - 一般的にgetter / setterと呼ばれる
      - getterとsetterの総称をアクセサという
      - `get + 対象のフィールドの名称`をキャメルケースで記述する
      - ex:
```java
   public class Hero {
     private String name;
     ...
     public String getName() {
       return this.name;
     }
   }
```

- カプセル化とデータ隠蔽
  - カプセル化
    - フィールドとそれを操作するメソッドが対象
    - `private`によってデータは隠して
    - `public`によって外部にはメソッドを入口として提供すること
    - データと機能をクラスの中にひとまとめにすること
  - データ隠蔽
    - カプセル化に必要なもの
    - 対象をフィールドとして`private`をつけて外部から直接触れなくする

  - 情報隠蔽
    - プログラミングのルールというより、もっと大きな設計思想
    - 「内部の仕組みは見せず、外部には使い方（インターフェース）だけを公開する」

 - 静的メンバ
  - 静的フィールドと静的メソッド（クラスメソッド）がある
  - クラスに紐づく
  - インスタンスを生成しなくても共有可能
  - フィールドに`static`をつけるのは、`public static final`として定数を共有する目的で利用されるのが一般的
  - クラス変数の宣言
    - `static int money`
  - クラス変数へのアクセス
    - `クラス名.静的フィールド名`
  - クラスメソッドの宣言
    - `static void attack()`
  - クラスメソッド呼び出し
    - 同パッケージ内
      - `クラス名 クラスメソッド名()`
      - インポートなしで呼び出せる
    - 別パッケージ
      - インポートしないと呼び出せない
```java
   import パッケージ名 クラス名;
   クラス名 クラスメソッド名();
```
  - 静的メンバのインポート
    - `import static パッケージ名.クラス名.静的メンバ名;`
      - 静的メンバ名の代わりに`*`を指定すると、そのクラスに属するすべての静的メンバが対象になる
      
</details>

<details>
<summary>修飾子</summary>

- 修飾子は順不同で記述可能
- final
  - 続く変数などを上書き不可にする
  - `final`をつけた変数を定数という
  - 定数なので大文字ですべて記述する
  - `final 型名 定数名 = 初期値`
  - 初期化せず定義だけした場合、一度だけ値の代入が可能
    
</details>

<details>
<summary>書き方一覧</summary>

- 定義
  
| 大分類 | 小分類 | 名前 | 書き方 |
|---|---|---|---|
| フィールド | クラス内 | クラスでのフィールド | `修飾子 型名 フィールド名;` |
| フィールド | インターフェース内 |インターフェースでのフィールド | `型名 フィールド名;` |
| メソッド | クラス内 | メソッド | `public static void メソッド名() { ... }` |
| メソッド | インターフェース内 | インターフェースでのメソッド | `戻り値 メソッド名();` |
| コンストラクタ | クラス内 | コンストラクタ | `public クラス名()` |
| 初期化子 | クラス | インスタンス初期化子 | `{ 処理内容 }` |
| 初期化子 | クラス | クラス初期化子（静的初期化ブロック） | `static { 処理内容 }` |
| クラス | 子クラス | extends | `public class 子クラス名 extends 親クラス名` |
| クラス | インターフェースを継承する | implements |`public class クラス名 implements インターフェース名 { ... }` |
| クラス | インターフェースを複数継承する | 多重継承 |`public class クラス名 implements 親インターフェース名1, 親インターフェース名2,... { ... }` |
| インターフェース | インターフェース | インターフェースを継承したインターフェース | `public interface インターフェース名 extends 親インターフェース名 { ... }` |
| インターフェース | インターフェース | インターフェースを複数継承したインターフェース | `public interface インターフェース名 extends 親インターフェース名1, 親インターフェース名2... { ... }` |
| インターフェース | クラス | インターフェースと親クラスを両方継承する | `public class クラス名 extends 親クラス implements 親インターフェース名1, 親インターフェース名2, ... { ... }` |


- 初期化
  
| 種別 | 場合 | 書き方 |
|---|---|---|
| フィールド | インターフェース内 | `型名 変数名 = 値;` |
| インスタンス | 引数を渡すインスタンス生成 | `クラス名 インスタンス名 = new クラス名(実引数1, 実引数2...);` |
| メソッド | インターフェース内で処理内容を持たせる場合 | `default 戻り値の型 メソッド名(引数リスト) { 処理のデフォルト実装 }` |


- 呼び出し
  
| 種別 | 書き方 |
|---|---|
| staticフィールド | `クラス名.フィールド名` |
| メソッド | `メソッド名()` |
| 親インスタンス部分のメソッド | `super.メソッド名(引数)` |
| 他のコンストラクタ | `this(引数);` |
| 親クラスのコンストラクタ | `super(引数);` |
| 完全限定クラス名 | `パッケージ名.クラス名` |

| | 書き方 |
|---|---|
| 自分自身のインスタンスの | `this.` |
| 今より1つ親側のフィールドを指す | `super.フィールド名` |

| | | 書き方 |
|---|---|---|
| インポート | パッケージ内のすべてのクラス | `import パッケージ名.*;` |
| インポート | クラス | `import パッケージ名.クラス名;` |

- メンバへのアクセス制御レベル
  
| 制限レベル | 名称 | 指定方法 | アクセスを許可する範囲 | インターフェース内 |
|---|---|---|---|---|
| 制限が厳しい | private | private | 自分自身のクラスのみ | インターフェース内のメソッドに使えるがヘルパー関数のみ |
|     ↓       | package private | (何も書かない) | 自分と同じパッケージに属するクラス | |
|     ↓       | protected | protected | 自分と同じパッケージに属するか、自分を継承した子クラス | |
| 制限が緩い | public | public | すべてのクラス| 自動付与 |

- クラスへのアクセス制御
  
| 制限レベル | 名称 | 指定方法 | アクセスを許可する範囲 |
|---|---|---|---|
| 厳しい | package private | (何も書かない) | 自分と同じパッケージに属するクラス |
| 緩い | public | public | すべてのクラス |


- アクセス修飾子以外の修飾子

| | インターフェース名 | クラス名 | オーバーライド | メソッド名 | フィールド名 |
|---|---|---|---|---|
| static | 使用不可 | 使用不可 | 不可 | インターフェースから直接呼び出せる。クラスでも定義可。継承とインスタンス化不可 | すべて同じ実体として扱われる。インスタンス化しても新しい実体にならない |
| final | インターフェースは継承前提なので継承禁止にするfinalは使えない | 継承不可にする | 不可 | オーバーライド不可にする | 定数にする |
| abstract | 抽象メソッドには自動付与 | 抽象クラスになる | 抽象メソッドになる | 使用不可 |

- 継承のキーワード
  
| 継承元 | 継承先 | キーワード | 継承元の数 |
|---|---|---|---|
| クラス | クラス | extends | 1つ |
| インターフェース | クラス | implements | 1つ以上 |
| インターフェース | インターフェース | extends | 1つ以上 |

</details>
